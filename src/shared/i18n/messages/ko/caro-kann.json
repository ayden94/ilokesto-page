{
  "introduce": {
    "title": "caro-kann을 소개합니다",
    "description": "caro-kann은 useSyncExternalStore 훅을 내부적으로 사용해 만든 전역 상태 관리 도구입니다. TypeScript를 지원하며 Next.js와 React.js 모두 호환됩니다. useState와 유사한 문법으로 React.js에 익숙한 개발자라면 직관적으로 사용할 수 있습니다.",
    "whatsNew": "caro-kann@4.0.0에서 새로 추가된 것",
    "newArray": {
      "0": "이제 zustand 미들웨어는 완전히 제거되었습니다. 또한 validate 미들웨어의 사용법이 변경되었습니다.",
      "1": "<cd>useStore.derived</cd>가 <cd>useStore.readOnly</cd>로 이름이 변경되었습니다. 또한 useStore에 <cd>writeOnly</cd> 메서드가 추가되었습니다. 이를 통해 상태를 변경시켜야 하지만, 상태를 직접 구독할 필요가 없는 컴포넌트에서도 더욱 명확하고 효율적으로 상태 관리를 할 수 있게 되었습니다. 이러한 변경은 코드의 의도를 더욱 분명하게 하며, 불필요한 리렌더링을 줄이는 데에도 기여합니다.",
      "2": "지난 버전에서 사라졌던 provider가 돌아왔습니다. 이를 통해 특정 컨텍스트에서 독립적인 상태 트리를 구성할 수 있어, 애플리케이션의 유연성과 재사용성이 한층 높아졌습니다.",
      "3": "선택자 함수를 작성할 때 따라야 할 규칙이 모두 제거되었습니다. 이에 따라 개발자는 불필요한 제약 없이 자유롭게 선택자 함수를 정의할 수 있게 되었으며, 이는 코드의 유연성과 표현력을 높이는 데 기여합니다. 내부적으로는 선택자 처리 방식이 개선되어, 이러한 자유에도 불구하고 성능 저하 없이 안정적인 상태 관리가 가능해졌습니다.",
      "4": "이제 선택자 함수의 유무에 관계 없이 <cd>setValue</cd>는 항상 일관된 방식으로 동작합니다. 이 변화는 API의 직관성을 높이고, 예외적인 동작으로 인한 버그 발생 가능성을 줄이는 데 큰 도움이 됩니다. 결과적으로 개발자는 보다 예측 가능하고 안정적인 방식으로 상태를 업데이트할 수 있습니다.",
      "5": "복잡한 객체 상태를 간편하게 변경하기 위해 <cd>setValue</cd>에 사용할 수 있는 유틸리티 함수 <cd>adaptor</cd>가 추가되었습니다.",
      "6": "여러 <cd>useStore</cd>를 하나로 병합하는 유틸리티 함수 merge가 추가되었습니다. 이를 통해 개발자는 `선택자 함수 + adaptor`를 사용한 top-down 방식으로도, `merge`를 사용한 Bottom-up 방식으로도 유연하게 상태를 구성할 수 있게 되었습니다. 각 방식은 컴포넌트 구조나 데이터 흐름에 따라 선택적으로 적용할 수 있어, 다양한 아키텍처 요구사항에 효과적으로 대응할 수 있습니다. 전체적으로 이번 업데이트는 일관성과 확장성을 모두 고려한 개선으로, 실제 개발 환경에서의 생산성과 유지보수성을 크게 향상시킵니다."
    },
    "installation": "설치 방법",
    "installationBody": "Caro-Kann은 아래의 다양한 방법으로 설치할 수 있습니다."
  },
  "tutorials": {
    "title": "튜토리얼 : 장바구니 만들기",
    "description": "이 튜토리얼에서는 React 환경에서 Caro-Kann 라이브러리를 활용하여 간단하면서도 실용적인 장바구니 기능을 구현하는 과정을 안내합니다. Caro-Kann이 제공하는 직관적인 상태 관리 방식과 강력한 미들웨어 시스템을 통해 어떻게 효율적으로 상태를 다루고, 다양한 부가 기능을 손쉽게 통합할 수 있는지 배우게 됩니다.<br></br><br></br>이 튜토리얼은 React에 대한 기본적인 이해가 있는 개발자를 대상으로 하며, Caro-Kann의 핵심 개념과 실제 사용법을 익혀 실제 프로젝트에 적용할 수 있도록 돕는 것을 목표로 합니다.",
    "createStore": {
      "title": "store 만들기",
      "0": "애플리케이션의 상태 관리를 시작하기 전에, 먼저 우리가 다룰 데이터의 구조를 정의하는 것이 좋습니다. 여기서는 장바구니에 담길 '제품(Product)'의 속성을 명확히 하기 위해 TypeScript 타입을 생성합니다. 각 제품은 고유 id, name, price를 필수적으로 가지며, 선택적으로 imageUrl과 description을 포함할 수 있도록 정의합니다. 이렇게 타입을 미리 정의하면 개발 과정에서 발생할 수 있는 데이터 관련 오류를 줄이고 코드의 가독성과 유지보수성을 높일 수 있습니다.",
      "1": "다음으로, caro-kann 라이브러리에서 <cd>create</cd> 함수를 가져와 전역 상태 저장소(store)를 생성합니다. create 함수는 초기 상태값을 인자로 받아, 해당 상태를 관리할 수 있는 커스텀 훅(hook)을 반환합니다. 이 예제에서는 빈 배열 []을 초기 상태로 설정하여, 처음에는 장바구니가 비어있음을 나타냅니다. <cd>create'<'Array'<'Product'>>'([])</cd> 호출 결과로 반환된 <cd>useCart</cd> 훅은 이제 우리 애플리케이션의 모든 컴포넌트에서 장바구니 상태에 접근하고 이를 변경하는 데 사용될 핵심 인터페이스가 됩니다."
    },
    "useCart": {
      "title": "useCart로 전역 상태 변경하기",
      "0": "이제 생성한 <cd>useCart</cd> 훅을 사용하여 실제 컴포넌트에서 장바구니 상태를 변경하는 방법을 살펴보겠습니다.<br></br><br></br>먼저 <cd>ProductBinder</cd> 컴포넌트는 서버로부터 받아온 제품 목록(<cd>productList</cd>)을 props로 받아, 각 제품에 대해 <cd>ProductCard</cd> 컴포넌트를 렌더링하는 역할을 합니다. 이는 일종의 리스트 렌더러로, 여러 제품 정보를 화면에 표시하기 위한 컨테이너 역할을 수행합니다.",
      "1": "이 컴포넌트 내부에서 <cd>useCart()</cd> 훅을 호출하면, React의 <cd>useState</cd> 훅과 유사하게 현재 장바구니 상태(<cd>cart</cd>)와 상태를 변경할 수 있는 함수(<cd>setCart</cd>)를 담은 튜플을 반환받습니다.",
      "2": "'Add to Cart' 버튼의 <cd>onClick</cd> 핸들러에서는 <cd>setCart</cd> 함수를 사용합니다. 이때, 이전 상태(<cd>prev</cd>)를 받아 새로운 제품(<cd>product</cd>)을 배열의 끝에 추가한 새로운 배열을 반환하는 함수형 업데이트 방식을 사용합니다 (<cd>setCart(prev => [...prev, product])</cd>). 이는 상태의 불변성을 유지하는 좋은 패턴이며, React가 변경 사항을 감지하고 UI를 효율적으로 업데이트하는 데 도움을 줍니다.<br></br><br></br>하지만 <cd>ProductBinder</cd> 컴포넌트의 현재 구현을 보면, 장바구니의 내용을 화면에 표시하지는 않습니다. 즉, <cd>cart</cd> 상태값을 직접 읽을 필요는 없고, 오직 <cd>setCart</cd>함수를 통해 장바구니에 아이템을 추가하는 기능만 수행합니다. 이런 경우, 컴포넌트가 장바구니 상태가 변경될 때마다 불필요하게 리렌더링되는 것을 방지하기 위해 최적화를 고려할 수 있습니다.<br></br><br></br>Caro-Kann은 이러한 상황을 위해 <cd>useCart</cd> 훅에 내장된 <cd>writeOnly</cd> 메서드를 제공합니다. <cd>useCart.writeOnly()</cd>를 사용하면 상태 값 자체는 가져오지 않고, 오직 상태를 변경하는 함수(<cd>setCart</cd>에 해당)만을 반환받습니다.",
      "3": "이를 통해 <cd>ProductBinder</cd> 컴포넌트는 장바구니의 현재 상태 변화에는 구독하지 않게 되어, 오직 제품을 추가하는 역할만 수행하면서도 불필요한 리렌더링을 피할 수 있습니다. 이는 특히 상태 변경이 잦거나 많은 컴포넌트가 동일한 상태를 공유할 때 성능 향상에 기여할 수 있는 유용한 최적화 기법입니다."
    },
    "readOnly": {
      "title": "readOnly 메서드로 파생 상태 관리하기",
      "0": "애플리케이션의 헤더(Header) 컴포넌트는 사용자에게 현재 장바구니에 담긴 제품의 총 개수를 시각적으로 보여주는 중요한 역할을 합니다. 이 기능을 구현하기 위해 <cd>useCart</cd> 훅의 <cd>readOnly</cd> 메서드를 활용합니다.<br></br><br></br><cd>readOnly</cd> 메서드는 상태 저장소의 현재 값에 접근하여 원하는 데이터를 추출하거나 계산할 수 있게 해주는 강력한 기능입니다. 이 메서드는 콜백 함수를 인자로 받으며, 이 콜백 함수는 현재 상태(<cd>store</cd>)를 매개변수로 받아 파생된 값을 반환합니다.<br></br><br></br>아래 예시에서는 <cd>useCart.readOnly(store => store.length)</cd>와 같이 사용하여, 장바구니 배열(<cd>store</cd>)의 <cd>length</cd> 프로퍼티를 통해 담긴 제품의 총 개수(<cd>cartLength</cd>)를 계산합니다.",
      "1": "<cd>readOnly</cd>를 사용하는 주된 이점은 다음과 같습니다.",
      "2": "결과적으로 <cd>useCart.readOnly</cd>는 상태의 특정 부분이나 파생된 값에만 의존하는 컴포넌트를 만들 때 매우 유용하며, 애플리케이션의 반응성과 성능을 향상시키는 데 도움을 줍니다.",
      "list": {
        "0": "<b>선택적 구독 (Selective Subscription)</b>: 컴포넌트는 전체 상태 객체가 아닌, 콜백 함수가 반환하는 특정 값의 변경에만 반응하여 리렌더링됩니다. 예를 들어, 장바구니에 제품이 추가되거나 삭제되어 <cd>store.length</cd>가 변경될 때만 <cd>Header</cd> 컴포넌트가 리렌더링됩니다. 만약 장바구니 내의 특정 아이템의 속성만 변경되고 전체 개수는 그대로라면, 이 컴포넌트는 리렌더링되지 않아 불필요한 연산을 줄일 수 있습니다.",
        "1": "<b>파생 상태 계산</b>: 단순히 상태의 일부를 가져오는 것뿐만 아니라, 상태를 기반으로 계산된 값(파생 상태)을 만들 수 있습니다. 예를 들어, 장바구니 총액을 계산하거나, 특정 조건에 맞는 아이템의 개수만 필터링하여 보여주는 등의 로직을 <cd>readOnly</cd> 콜백 내에서 처리할 수 있습니다.",
        "2": "<b>성능 최적화</b>: 필요한 데이터만 정확히 구독함으로써, 상태의 다른 부분이 변경될 때 발생하는 불필요한 리렌더링을 방지합니다. 이는 특히 복잡한 상태 구조나 빈번한 상태 업데이트가 있는 애플리케이션에서 성능 최적화에 크게 기여합니다."
      }
    },
    "cartPage": {
      "title": "장바구니 페이지 만들기",
      "0": "장바구니 페이지는 사용자가 선택한 상품들의 목록을 보여주고, 각 상품을 제거하거나 전체 장바구니를 비우는 기능을 제공합니다. 또한, 장바구니에 담긴 모든 상품의 총액을 계산하여 표시합니다. 이 페이지는 주로 <cd>Cart</cd> 컴포넌트로 구성되며, 각 장바구니 아이템은 <cd>ProductCard</cd> (또는 별도의 <cd>CartItemCard</cd>)를 통해 렌더링될 수 있습니다.<br></br><br></br>Cart 컴포넌트에서는 <cd>useCart</cd> 훅에 selector 함수를 전달하여 필요한 데이터만 효율적으로 가져옵니다. 이 selector 함수는 현재 장바구니 상태(<cd>store</cd>)를 인자로 받아, 장바구니 아이템 목록(<cd>items</cd>)과 전체 아이템의 가격 합계(<cd>priceTotal</cd>)를 포함하는 객체를 반환합니다. 이렇게 하면 <cd>Cart</cd> 컴포넌트는 장바구니 아이템 또는 총액이 변경될 때만 리렌더링됩니다.",
      "list": {
        "0": "<cd>items</cd>: 현재 장바구니에 담긴 상품 객체들의 배열입니다.",
        "1": "<cd>priceTotal</cd>: <cd>items</cd> 배열의 각 <cd>product.price</cd>를 합산한 총액입니다."
      }
    }
  }
}

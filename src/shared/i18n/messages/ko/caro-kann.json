{
  "introduce": {
    "title": "caro-kann을 소개합니다",
    "description": "caro-kann은 useSyncExternalStore 훅을 내부적으로 사용해 만든 전역 상태 관리 도구입니다. TypeScript를 지원하며 Next.js와 React.js 모두 호환됩니다. useState와 유사한 문법으로 React.js에 익숙한 개발자라면 직관적으로 사용할 수 있습니다.",
    "whatsNew": "caro-kann@4.0.0에서 새로 추가된 것",
    "newArray": {
      "0": "이제 zustand 미들웨어는 완전히 제거되었습니다. 또한 validate 미들웨어의 사용법이 변경되었습니다.",
      "1": "<cd>useStore.derived</cd>가 <cd>useStore.readOnly</cd>로 이름이 변경되었습니다. 또한 useStore에 <cd>writeOnly</cd> 메서드가 추가되었습니다. 이를 통해 상태를 변경시켜야 하지만, 상태를 직접 구독할 필요가 없는 컴포넌트에서도 더욱 명확하고 효율적으로 상태 관리를 할 수 있게 되었습니다. 이러한 변경은 코드의 의도를 더욱 분명하게 하며, 불필요한 리렌더링을 줄이는 데에도 기여합니다.",
      "2": "지난 버전에서 사라졌던 provider가 돌아왔습니다. 이를 통해 특정 컨텍스트에서 독립적인 상태 트리를 구성할 수 있어, 애플리케이션의 유연성과 재사용성이 한층 높아졌습니다.",
      "3": "선택자 함수를 작성할 때 따라야 할 규칙이 모두 제거되었습니다. 이에 따라 개발자는 불필요한 제약 없이 자유롭게 선택자 함수를 정의할 수 있게 되었으며, 이는 코드의 유연성과 표현력을 높이는 데 기여합니다. 내부적으로는 선택자 처리 방식이 개선되어, 이러한 자유에도 불구하고 성능 저하 없이 안정적인 상태 관리가 가능해졌습니다.",
      "4": "이제 선택자 함수의 유무에 관계 없이 <cd>setValue</cd>는 항상 일관된 방식으로 동작합니다. 이 변화는 API의 직관성을 높이고, 예외적인 동작으로 인한 버그 발생 가능성을 줄이는 데 큰 도움이 됩니다. 결과적으로 개발자는 보다 예측 가능하고 안정적인 방식으로 상태를 업데이트할 수 있습니다.",
      "5": "복잡한 객체 상태를 간편하게 변경하기 위해 <cd>setValue</cd>에 사용할 수 있는 유틸리티 함수 <cd>adaptor</cd>가 추가되었습니다.",
      "6": "여러 <cd>useStore</cd>를 하나로 병합하는 유틸리티 함수 merge가 추가되었습니다. 이를 통해 개발자는 `선택자 함수 + adaptor`를 사용한 top-down 방식으로도, `merge`를 사용한 Bottom-up 방식으로도 유연하게 상태를 구성할 수 있게 되었습니다. 각 방식은 컴포넌트 구조나 데이터 흐름에 따라 선택적으로 적용할 수 있어, 다양한 아키텍처 요구사항에 효과적으로 대응할 수 있습니다. 전체적으로 이번 업데이트는 일관성과 확장성을 모두 고려한 개선으로, 실제 개발 환경에서의 생산성과 유지보수성을 크게 향상시킵니다."
    },
    "installation": "설치 방법",
    "installationBody": "Caro-Kann은 아래의 다양한 방법으로 설치할 수 있습니다."
  },
  "tutorials": {
    "title": "튜토리얼 : 장바구니 만들기",
    "description": "이 튜토리얼에서는 React 환경에서 Caro-Kann 라이브러리를 활용하여 간단하면서도 실용적인 장바구니 기능을 구현하는 과정을 안내합니다. Caro-Kann이 제공하는 직관적인 상태 관리 방식과 강력한 미들웨어 시스템을 통해 어떻게 효율적으로 상태를 다루고, 다양한 부가 기능을 손쉽게 통합할 수 있는지 배우게 됩니다.<br></br><br></br>이 튜토리얼은 React에 대한 기본적인 이해가 있는 개발자를 대상으로 하며, Caro-Kann의 핵심 개념과 실제 사용법을 익혀 실제 프로젝트에 적용할 수 있도록 돕는 것을 목표로 합니다.",
    "createStore": {
      "title": "store 만들기",
      "0": "애플리케이션의 상태 관리를 시작하기 전에, 먼저 우리가 다룰 데이터의 구조를 정의하는 것이 좋습니다. 여기서는 장바구니에 담길 '제품(Product)'의 속성을 명확히 하기 위해 TypeScript 타입을 생성합니다. 각 제품은 고유 id, name, price를 필수적으로 가지며, 선택적으로 imageUrl과 description을 포함할 수 있도록 정의합니다. 이렇게 타입을 미리 정의하면 개발 과정에서 발생할 수 있는 데이터 관련 오류를 줄이고 코드의 가독성과 유지보수성을 높일 수 있습니다.",
      "1": "다음으로, caro-kann 라이브러리에서 <cd>create</cd> 함수를 가져와 전역 상태 저장소(store)를 생성합니다. create 함수는 초기 상태값을 인자로 받아, 해당 상태를 관리할 수 있는 커스텀 훅(hook)을 반환합니다. 이 예제에서는 빈 배열 []을 초기 상태로 설정하여, 처음에는 장바구니가 비어있음을 나타냅니다. <cd>create'<'Array'<'Product'>>'([])</cd> 호출 결과로 반환된 <cd>useCart</cd> 훅은 이제 우리 애플리케이션의 모든 컴포넌트에서 장바구니 상태에 접근하고 이를 변경하는 데 사용될 핵심 인터페이스가 됩니다."
    },
    "useCart": {
      "title": "useCart로 전역 상태 변경하기",
      "0": "이제 생성한 <cd>useCart</cd> 훅을 사용하여 실제 컴포넌트에서 장바구니 상태를 변경하는 방법을 살펴보겠습니다.<br></br><br></br>먼저 <cd>ProductBinder</cd> 컴포넌트는 서버로부터 받아온 제품 목록(<cd>productList</cd>)을 props로 받아, 각 제품에 대해 <cd>ProductCard</cd> 컴포넌트를 렌더링하는 역할을 합니다. 이는 일종의 리스트 렌더러로, 여러 제품 정보를 화면에 표시하기 위한 컨테이너 역할을 수행합니다.",
      "1": "이 컴포넌트 내부에서 <cd>useCart()</cd> 훅을 호출하면, React의 <cd>useState</cd> 훅과 유사하게 현재 장바구니 상태(<cd>cart</cd>)와 상태를 변경할 수 있는 함수(<cd>setCart</cd>)를 담은 튜플을 반환받습니다."
    }
  }
}

{
  "introduce": {
    "title": "caro-kann을 소개합니다",
    "description": "caro-kann은 useSyncExternalStore 훅을 내부적으로 사용해 만든 전역 상태 관리 도구입니다. TypeScript를 지원하며 Next.js와 React.js 모두 호환됩니다. useState와 유사한 문법으로 React.js에 익숙한 개발자라면 직관적으로 사용할 수 있습니다.",
    "whatsNew": "caro-kann@4.0.0에서 새로 추가된 것",
    "newArray": {
      "0": "이제 zustand 미들웨어는 완전히 제거되었습니다. 또한 validate 미들웨어의 사용법이 변경되었습니다.",
      "1": "<cd>useStore.derived</cd>가 <cd>useStore.readOnly</cd>로 이름이 변경되었습니다. 또한 useStore에 <cd>writeOnly</cd> 메서드가 추가되었습니다. 이를 통해 상태를 변경시켜야 하지만, 상태를 직접 구독할 필요가 없는 컴포넌트에서도 더욱 명확하고 효율적으로 상태 관리를 할 수 있게 되었습니다. 이러한 변경은 코드의 의도를 더욱 분명하게 하며, 불필요한 리렌더링을 줄이는 데에도 기여합니다.",
      "2": "지난 버전에서 사라졌던 provider가 돌아왔습니다. 이를 통해 특정 컨텍스트에서 독립적인 상태 트리를 구성할 수 있어, 애플리케이션의 유연성과 재사용성이 한층 높아졌습니다.",
      "3": "선택자 함수를 작성할 때 따라야 할 규칙이 모두 제거되었습니다. 이에 따라 개발자는 불필요한 제약 없이 자유롭게 선택자 함수를 정의할 수 있게 되었으며, 이는 코드의 유연성과 표현력을 높이는 데 기여합니다. 내부적으로는 선택자 처리 방식이 개선되어, 이러한 자유에도 불구하고 성능 저하 없이 안정적인 상태 관리가 가능해졌습니다.",
      "4": "이제 선택자 함수의 유무에 관계 없이 <cd>setValue</cd>는 항상 일관된 방식으로 동작합니다. 이 변화는 API의 직관성을 높이고, 예외적인 동작으로 인한 버그 발생 가능성을 줄이는 데 큰 도움이 됩니다. 결과적으로 개발자는 보다 예측 가능하고 안정적인 방식으로 상태를 업데이트할 수 있습니다.",
      "5": "복잡한 객체 상태를 간편하게 변경하기 위해 <cd>setValue</cd>에 사용할 수 있는 유틸리티 함수 <cd>adaptor</cd>가 추가되었습니다.",
      "6": "여러 <cd>useStore</cd>를 하나로 병합하는 유틸리티 함수 merge가 추가되었습니다. 이를 통해 개발자는 `선택자 함수 + adaptor`를 사용한 top-down 방식으로도, `merge`를 사용한 Bottom-up 방식으로도 유연하게 상태를 구성할 수 있게 되었습니다. 각 방식은 컴포넌트 구조나 데이터 흐름에 따라 선택적으로 적용할 수 있어, 다양한 아키텍처 요구사항에 효과적으로 대응할 수 있습니다. 전체적으로 이번 업데이트는 일관성과 확장성을 모두 고려한 개선으로, 실제 개발 환경에서의 생산성과 유지보수성을 크게 향상시킵니다."
    },
    "installation": "설치 방법",
    "installationBody": "caro-kann은 아래의 다양한 방법으로 설치할 수 있습니다."
  },
  "tutorials": {
    "title": "튜토리얼 : 장바구니 만들기",
    "description": "이 튜토리얼에서는 React 환경에서 caro-kann 라이브러리를 활용하여 간단하면서도 실용적인 장바구니 기능을 구현하는 과정을 안내합니다. caro-kann이 제공하는 직관적인 상태 관리 방식과 강력한 미들웨어 시스템을 통해 어떻게 효율적으로 상태를 다루고, 다양한 부가 기능을 손쉽게 통합할 수 있는지 배우게 됩니다.<br></br><br></br>이 튜토리얼은 React에 대한 기본적인 이해가 있는 개발자를 대상으로 하며, caro-kann의 핵심 개념과 실제 사용법을 익혀 실제 프로젝트에 적용할 수 있도록 돕는 것을 목표로 합니다.",
    "createStore": {
      "title": "store 만들기",
      "0": "애플리케이션의 상태 관리를 시작하기 전에, 먼저 우리가 다룰 데이터의 구조를 정의하는 것이 좋습니다. 여기서는 장바구니에 담길 '제품(Product)'의 속성을 명확히 하기 위해 TypeScript 타입을 생성합니다. 각 제품은 고유 id, name, price를 필수적으로 가지며, 선택적으로 imageUrl과 description을 포함할 수 있도록 정의합니다. 이렇게 타입을 미리 정의하면 개발 과정에서 발생할 수 있는 데이터 관련 오류를 줄이고 코드의 가독성과 유지보수성을 높일 수 있습니다.",
      "1": "다음으로, caro-kann 라이브러리에서 <cd>create</cd> 함수를 가져와 전역 상태 저장소(store)를 생성합니다. create 함수는 초기 상태값을 인자로 받아, 해당 상태를 관리할 수 있는 커스텀 훅(hook)을 반환합니다. 이 예제에서는 빈 배열 []을 초기 상태로 설정하여, 처음에는 장바구니가 비어있음을 나타냅니다. <cd>create'<'Array'<'Product'>>'([])</cd> 호출 결과로 반환된 <cd>useCart</cd> 훅은 이제 우리 애플리케이션의 모든 컴포넌트에서 장바구니 상태에 접근하고 이를 변경하는 데 사용될 핵심 인터페이스가 됩니다."
    },
    "useCart": {
      "title": "useCart로 전역 상태 변경하기",
      "0": "이제 생성한 <cd>useCart</cd> 훅을 사용하여 실제 컴포넌트에서 장바구니 상태를 변경하는 방법을 살펴보겠습니다.<br></br><br></br>먼저 <cd>ProductBinder</cd> 컴포넌트는 서버로부터 받아온 제품 목록(<cd>productList</cd>)을 props로 받아, 각 제품에 대해 <cd>ProductCard</cd> 컴포넌트를 렌더링하는 역할을 합니다. 이는 일종의 리스트 렌더러로, 여러 제품 정보를 화면에 표시하기 위한 컨테이너 역할을 수행합니다.",
      "1": "이 컴포넌트 내부에서 <cd>useCart()</cd> 훅을 호출하면, React의 <cd>useState</cd> 훅과 유사하게 현재 장바구니 상태(<cd>cart</cd>)와 상태를 변경할 수 있는 함수(<cd>setCart</cd>)를 담은 튜플을 반환받습니다.",
      "2": "'Add to Cart' 버튼의 <cd>onClick</cd> 핸들러에서는 <cd>setCart</cd> 함수를 사용합니다. 이때, 이전 상태(<cd>prev</cd>)를 받아 새로운 제품(<cd>product</cd>)을 배열의 끝에 추가한 새로운 배열을 반환하는 함수형 업데이트 방식을 사용합니다 (<cd>setCart(prev => [...prev, product])</cd>). 이는 상태의 불변성을 유지하는 좋은 패턴이며, React가 변경 사항을 감지하고 UI를 효율적으로 업데이트하는 데 도움을 줍니다.<br></br><br></br>하지만 <cd>ProductBinder</cd> 컴포넌트의 현재 구현을 보면, 장바구니의 내용을 화면에 표시하지는 않습니다. 즉, <cd>cart</cd> 상태값을 직접 읽을 필요는 없고, 오직 <cd>setCart</cd>함수를 통해 장바구니에 아이템을 추가하는 기능만 수행합니다. 이런 경우, 컴포넌트가 장바구니 상태가 변경될 때마다 불필요하게 리렌더링되는 것을 방지하기 위해 최적화를 고려할 수 있습니다.<br></br><br></br>caro-kann은 이러한 상황을 위해 <cd>useCart</cd> 훅에 내장된 <cd>writeOnly</cd> 메서드를 제공합니다. <cd>useCart.writeOnly()</cd>를 사용하면 상태 값 자체는 가져오지 않고, 오직 상태를 변경하는 함수(<cd>setCart</cd>에 해당)만을 반환받습니다.",
      "3": "이를 통해 <cd>ProductBinder</cd> 컴포넌트는 장바구니의 현재 상태 변화에는 구독하지 않게 되어, 오직 제품을 추가하는 역할만 수행하면서도 불필요한 리렌더링을 피할 수 있습니다. 이는 특히 상태 변경이 잦거나 많은 컴포넌트가 동일한 상태를 공유할 때 성능 향상에 기여할 수 있는 유용한 최적화 기법입니다."
    },
    "readOnly": {
      "title": "readOnly 메서드로 파생 상태 관리하기",
      "0": "애플리케이션의 헤더(Header) 컴포넌트는 사용자에게 현재 장바구니에 담긴 제품의 총 개수를 시각적으로 보여주는 중요한 역할을 합니다. 이 기능을 구현하기 위해 <cd>useCart</cd> 훅의 <cd>readOnly</cd> 메서드를 활용합니다.<br></br><br></br><cd>readOnly</cd> 메서드는 상태 저장소의 현재 값에 접근하여 원하는 데이터를 추출하거나 계산할 수 있게 해주는 강력한 기능입니다. 이 메서드는 콜백 함수를 인자로 받으며, 이 콜백 함수는 현재 상태(<cd>store</cd>)를 매개변수로 받아 파생된 값을 반환합니다.<br></br><br></br>아래 예시에서는 <cd>useCart.readOnly(store => store.length)</cd>와 같이 사용하여, 장바구니 배열(<cd>store</cd>)의 <cd>length</cd> 프로퍼티를 통해 담긴 제품의 총 개수(<cd>cartLength</cd>)를 계산합니다.",
      "1": "<cd>readOnly</cd>를 사용하는 주된 이점은 다음과 같습니다.",
      "2": "결과적으로 <cd>useCart.readOnly</cd>는 상태의 특정 부분이나 파생된 값에만 의존하는 컴포넌트를 만들 때 매우 유용하며, 애플리케이션의 반응성과 성능을 향상시키는 데 도움을 줍니다.",
      "list": {
        "0": "<b>선택적 구독 (Selective Subscription)</b>: 컴포넌트는 전체 상태 객체가 아닌, 콜백 함수가 반환하는 특정 값의 변경에만 반응하여 리렌더링됩니다. 예를 들어, 장바구니에 제품이 추가되거나 삭제되어 <cd>store.length</cd>가 변경될 때만 <cd>Header</cd> 컴포넌트가 리렌더링됩니다. 만약 장바구니 내의 특정 아이템의 속성만 변경되고 전체 개수는 그대로라면, 이 컴포넌트는 리렌더링되지 않아 불필요한 연산을 줄일 수 있습니다.",
        "1": "<b>파생 상태 계산</b>: 단순히 상태의 일부를 가져오는 것뿐만 아니라, 상태를 기반으로 계산된 값(파생 상태)을 만들 수 있습니다. 예를 들어, 장바구니 총액을 계산하거나, 특정 조건에 맞는 아이템의 개수만 필터링하여 보여주는 등의 로직을 <cd>readOnly</cd> 콜백 내에서 처리할 수 있습니다.",
        "2": "<b>성능 최적화</b>: 필요한 데이터만 정확히 구독함으로써, 상태의 다른 부분이 변경될 때 발생하는 불필요한 리렌더링을 방지합니다. 이는 특히 복잡한 상태 구조나 빈번한 상태 업데이트가 있는 애플리케이션에서 성능 최적화에 크게 기여합니다."
      }
    },
    "cartPage": {
      "title": "장바구니 페이지 만들기",
      "0": "장바구니 페이지는 사용자가 선택한 상품들의 목록을 보여주고, 각 상품을 제거하거나 전체 장바구니를 비우는 기능을 제공합니다. 또한, 장바구니에 담긴 모든 상품의 총액을 계산하여 표시합니다. 이 페이지는 주로 <cd>Cart</cd> 컴포넌트로 구성되며, 각 장바구니 아이템은 <cd>ProductCard</cd> (또는 별도의 <cd>CartItemCard</cd>)를 통해 렌더링될 수 있습니다.<br></br><br></br>Cart 컴포넌트에서는 <cd>useCart</cd> 훅에 selector 함수를 전달하여 필요한 데이터만 효율적으로 가져옵니다. 이 selector 함수는 현재 장바구니 상태(<cd>store</cd>)를 인자로 받아, 장바구니 아이템 목록(<cd>items</cd>)과 전체 아이템의 가격 합계(<cd>priceTotal</cd>)를 포함하는 객체를 반환합니다. 이렇게 하면 <cd>Cart</cd> 컴포넌트는 장바구니 아이템 또는 총액이 변경될 때만 리렌더링됩니다.",
      "list": {
        "0": "<cd>items</cd>: 현재 장바구니에 담긴 상품 객체들의 배열입니다.",
        "1": "<cd>priceTotal</cd>: <cd>items</cd> 배열의 각 <cd>product.price</cd>를 합산한 총액입니다."
      }
    },
    "middleware": {
      "title": "미들웨어 합성으로 장바구니 백업 및 동작 확인",
      "0": "caro-kann의 강력한 기능 중 하나는 미들웨어를 손쉽게 합성하여 스토어의 기능을 확장할 수 있다는 점입니다. 여기서는 장바구니 상태를 브라우저에 유지하고, 상태 변경을 쉽게 추적할 수 있도록 persist와 logger 미들웨어를 적용해 보겠습니다.",
      "subtitle1": "1. persist 미들웨어로 장바구니 상태 유지하기",
      "1": "기본적으로 웹 애플리케이션의 상태는 페이지를 새로고침하거나 브라우저를 닫으면 초기화됩니다. 사용자가 장바구니에 담은 상품들이 사라지지 않도록 하려면 상태를 어딘가에 저장해야 합니다. persist 미들웨어는 이러한 상태 영속성 관리를 매우 간단하게 만들어줍니다.<br></br><br></br>persist 미들웨어는 상태가 변경될 때마다 지정된 스토리지(예: localStorage)에 자동으로 데이터를 저장하고, 애플리케이션이 다시 로드될 때 저장된 데이터를 불러와 상태를 복원합니다. 다음은 persist 미들웨어를 useCart 스토어에 적용하는 방법입니다.",
      "subtitle2": "2. logger 미들웨어로 상태 변경 추적하기",
      "2": "개발 과정에서 상태가 어떻게 변경되는지, 어떤 액션에 의해 변경이 일어났는지 등을 파악하는 것은 디버깅에 매우 중요합니다. logger 미들웨어는 상태 변경과 관련된 정보를 콘솔에 출력하여 이러한 과정을 쉽게 추적할 수 있도록 도와줍니다.<br></br><br></br>logger 미들웨어는 persist 미들웨어와 함께 합성하여 사용할 수 있습니다. 미들웨어는 함수를 감싸는 형태로 적용되므로, 안쪽부터 바깥쪽 순서로 실행된다고 생각할 수 있습니다. 즉, 상태 변경이 일어나면 logger가 먼저 동작하고, 그 다음 persist가 동작합니다.",
      "3": "이제 장바구니에 상품을 추가하거나 제거할 때마다 브라우저 콘솔에 관련 로그가 출력되어, 상태 변경 과정을 명확하게 확인할 수 있습니다. logger의 옵션을 조정하여 필요한 정보만 선택적으로 볼 수도 있습니다."
    },
    "merge": {
      "title": "merge로 여러 스토어 합치기",
      "0": "애플리케이션의 규모가 커지면, 관련된 상태들을 별도의 스토어로 분리하여 관리하는 것이 더 효율적일 수 있습니다. 예를 들어, 장바구니 상태는 <cd>useCart</cd> 스토어에서, 사용자 프로필 정보는 <cd>useProfile</cd> 스토어에서 각각 관리할 수 있습니다.<br></br><br></br>caro-kann은 이렇게 분리된 여러 스토어를 하나의 통합된 훅으로 편리하게 사용하고 관리할 수 있도록 <cd>merge</cd> 유틸리티를 제공합니다. <cd>merge</cd>는 여러 스토어 훅을 입력받아, 각 스토어의 상태와 세터(setter) 함수에 접근할 수 있는 새로운 훅을 반환합니다.<br></br><br></br>먼저, 개별 스토어를 정의합니다. 여기서는 장바구니(<cd>useCart</cd>)와 사용자 프로필(<cd>useProfile</cd>) 스토어를 예시로 사용합니다. User 타입도 정의해야 합니다.",
      "1": "이제 <cd>merge</cd> 유틸리티를 사용하여 <cd>useCart</cd>와 <cd>useProfile</cd> 스토어를 하나로 합칩니다. <cd>merge</cd> 함수에 객체를 전달하며, 각 키는 합쳐진 스토어에서 사용될 이름이 되고 값은 해당 스토어 훅이 됩니다.",
      "2": "이렇게 생성된 <cd>useProfileAndCart</cd> 훅을 사용하면, 마치 하나의 큰 스토어를 다루는 것처럼 각 스토어의 상태와 세터 함수에 접근할 수 있습니다.<br></br><br></br>예를 들어, 컴포넌트 내에서 다음과 같이 사용할 수 있습니다."
    },
    "finishing": {
      "title": "마무리하며: caro-kann과 함께하는 효율적인 상태 관리",
      "0": "지금까지 caro-kann 라이브러리를 활용하여 기본적인 장바구니 기능을 구현하는 과정을 함께 살펴보았습니다. 이 튜토리얼을 통해 <cd>create</cd> 함수로 스토어를 생성하고, <cd>useCart</cd> 훅을 통해 상태를 읽고 업데이트하는 방법, <cd>writeOnly</cd>와 <cd>readOnly</cd> 메서드를 사용한 최적화, 그리고 <cd>selector</cd>를 활용한 파생 상태 관리 방법을 익혔습니다. 또한, <cd>persist</cd>와 <cd>logger</cd> 미들웨어를 합성하여 스토어의 기능을 손쉽게 확장하고, <cd>merge</cd> 유틸리티로 여러 스토어를 통합적으로 관리하는 방법도 알아보았습니다.<br></br><br></br>여기서 다룬 내용들은 caro-kann이 제공하는 다양한 기능의 일부에 불과합니다. 실제 애플리케이션 개발에서는 더욱 복잡한 상태 로직, 고급 미들웨어 활용 등 다양한 시나리오와 마주하게 될 것입니다. caro-kann은 이러한 고급 요구사항들을 충족시킬 수 있는 강력하고 유연한 기능들을 제공하며, 개발자가 상태 관리를 더욱 효율적이고 직관적으로 다룰 수 있도록 돕습니다.<br></br><br></br>더 깊이 있는 학습과 caro-kann의 모든 잠재력을 확인하고 싶다면, 공식 문서를 참조하시는 것을 적극 권장합니다. 공식 문서에서는 이 튜토리얼에서 다루지 못한 다양한 API, 고급 사용 패턴, 그리고 실제 프로덕션 환경에서의 모범 사례들을 자세히 안내하고 있습니다. caro-kann과 함께 더욱 즐겁고 생산적인 상태 관리 경험을 만들어가시길 바랍니다."
    }
  },
  "create-store": {
    "title": "store 만들기",
    "0": "caro-kann에서 store는 전역 상태가 저장되어있는 외부 공간으로 정의됩니다. 이러한 store를 만들기 위해서는 caro-kann이 제공하는 <cd>create</cd> 함수를 사용해야 합니다. 이 함수는 상태의 초기값을 매개변수로 받아 이를 내부 store에 저장하고 <cd>useStore</cd> 훅을 리턴합니다.<br></br><br></br><cd>create</cd> 함수는 반드시 컴포넌트 외부에서 호출해야 합니다. 컴포넌트 내부에서 호출하면 컴포넌트가 리렌더링될 때마다 새로운 store가 생성되어 이전 상태가 소실됩니다. 이는 전역 상태 관리의 목적에 반하는 동작이므로 각별히 주의해야 합니다.",
    "1": "<cd>useStore</cd> 훅은 <cd>create</cd> 함수를 통해 만들어진 store에 접근할 수 있는 유일한 방법이며, 리액트의 <cd>useState</cd> 훅과 동일하게 <cd>[ value, setValue ]</cd> 로 이루어진 튜플을 리턴합니다."
  },
  "basic-usage": {
    "title": "useStore의 기본 사용법",
    "0": "앞서 살펴본 바와 같이 <cd>useStore</cd>는 리액트의 <cd>useState</cd> 훅과 동일하게 <cd>[ value, setValue ]</cd> 로 이루어진 튜플을 리턴합니다. 따라서 리액트에 익숙한 개발자라면 누구라도 쉽게 <cd>useStore</cd>를 사용할 수 있습니다.",
    "subtitle1": "선택자 함수",
    "1": "위에서 살펴본 코드는 한 가지 문제를 안고 있습니다. 컴포넌트 내에서 필요한 상태는 email과 name, 그리고 phoneNumber이지만, <cd>useStore</cd>는 전체 store를 구독하고 있다는 사실입니다. 따라서 다른 곳에서 age 값이 변경될 경우, age 값이 필요하지 않은 <cd>ProfileCard</cd> 컴포넌트도 리랜더링 될 것입니다.<br></br><br></br>이러한 문제를 해결하기 위해 <cd>useStore</cd> 훅은 선택자 함수를 인자로 받을 수 있습니다. 선택자 함수를 사용하면 컴포넌트가 실제로 필요한 상태만 구독하여 불필요한 리랜더링을 방지할 수 있습니다. 이는 특히 상태 객체가 크고 복잡하거나, 성능이 중요한 애플리케이션에서 렌더링 최적화에 큰 도움이 됩니다.",
    "subtitle2": "파생 상태",
    "2": "선택자 함수는 필요한 상태만을 구독하여 불필요한 리렌더링을 방지할 뿐 아니라, 기존 상태를 변형하거나 계산하여 새로운 파생 상태를 만들 수도 있습니다.<br></br><br></br>예를 들어, 장바구니 아이템 목록에서 총 가격을 계산하거나, 사용자 데이터에서 성인 여부를 판단하는 등 복잡한 로직을 컴포넌트 외부로 분리할 수 있습니다. 이러한 접근 방식은 UI 컴포넌트를 더 간결하게 유지하고, 상태 로직을 재사용 가능한 형태로 관리할 수 있게 해줍니다.",
    "subtitle3": "readOnly와 writeOnly 메서드",
    "3": "useStore는 <cd>[value, setValue]</cd> 로 이루어진 튜플을 리턴합니다. 그런데 꼭 그래야 할까요? 지금까지 살펴본 <cd>ProfileCard</cd> 컴포넌트는 상태를 가져와 사용할 뿐, 상태를 변경하는 기능은 필요하지 않습니다. 이런 경우 <cd>setValue</cd> 함수는 사용되지 않아 불필요한 자원이 될 수 있습니다.<br></br><br></br>이러한 상황을 해결하기 위해 useStore는 <cd>readOnly</cd>와 <cd>writeOnly</cd> 메서드를 제공합니다. readOnly 메서드는 상태를 읽기만 하는 컴포넌트를 위한 것으로, 상태 값만 반환하고 업데이트 함수는 제공하지 않습니다. 반대로 writeOnly 메서드는 상태를 변경만 하고 구독은 하지 않을 때 사용할 수 있습니다. 이를 통해 컴포넌트의 실제 필요에 맞게 최적화된 인터페이스를 사용할 수 있습니다."
  },
  "provider": {
    "title": "Provider",
    "0": "useStore에는 특별한 메서드가 하나 더 숨겨져있습니다. Provider 메서드는 caro-kann에서 제공하는 특별한 기능으로, 동일한 store를 사용하면서도 독립적인 상태 트리를 구성할 수 있게 해줍니다. 이 기능을 통해 애플리케이션 내에서 같은 store의 서로 다른 인스턴스를 생성하고 관리할 수 있습니다.<br></br><br></br>Provider는 리액트 컴포넌트처럼 동작하며, store를 props로 받습니다. useStore는 create를 통해 생성된 store에 접근하는 수단이지, store 그 자체는 아닙니다. 따라서 caro-kann은 useStore 대신 store를 직접 리턴하는 createStore 함수를 제공합니다. 이를 통해 특정 컴포넌트 트리에 독립적인 상태를 제공할 수 있습니다.",
    "subtitle1": "활용 사례",
    "1": "provider는 다음과 같은 상황에서 특히 유용합니다:",
    "2": "provider를 통해 상태 관리의 유연성을 크게 향상시킬 수 있으며, 복잡한 애플리케이션에서 상태의 격리와 재사용성을 모두 달성할 수 있습니다.",
    "subtitle2": "provider와 middleware",
    "3": "나중에 자세히 살펴보겠지만 caro-kann의 middleware는 create와 createStore에 추가적인 기능을 부여합니다. 그리고 Provider는 스토어의 타입이 같다면 어떤 미들웨어를 어떤 순서로 사용하든 문제없이 동작합니다. 심지어 아래 예시처럼 create와 createStore에 서로 다른 미들웨어를 적용해도 정상적으로 작동합니다.",
    "4": "하지만 여기에는 한 가지 예외가 있습니다. create 함수에 reducer 미들웨어를 사용했다면 createStore 함수에도 동일하게 reducer 미들웨어를 사용해야 하며, 그 반대의 경우도 마찬가지입니다. 이는 reducer 미들웨어가 스토어의 상태를 변경하는 핵심 함수인 setValue의 동작 방식을 수정하기 때문입니다. 따라서 create와 createStore 간에 reducer 미들웨어 사용 여부가 일치하지 않으면, 상태 업데이트 로직에 예상치 못한 문제가 발생할 수 있습니다.<br></br><br></br>다행히 타입스크립트를 사용하면 caro-kann은 내부적으로 각각의 스토어에 적용된 미들웨어를 자동으로 파악합니다. 만약 reducer 미들웨어 사용에 불일치가 감지될 경우, 다음과 같은 경고 메시지를 통해 개발자에게 알려줍니다.",
    "5": "\"Warning: Reducer usage must be consistent. Both should use reducers, or neither should.\"",
    "6": "이를 통해 개발 과정에서 발생할 수 있는 잠재적인 오류를 미리 방지할 수 있도록 돕습니다.",
    "list": {
      "0": "<b>테스트 환경</b>: 각 테스트마다 독립적인 상태를 제공하여 격리된 테스트를 수행할 수 있습니다.",
      "1": "<b>다중 인스턴스 컴포넌트</b>: 같은 컴포넌트가 여러 번 사용되지만 서로 독립적인 상태를 가져야 하는 경우",
      "2": "<b>테마 관리</b>: 애플리케이션의 다른 부분에서 서로 다른 테마 설정을 사용해야 하는 경우",
      "3": "<b>사용자별 설정</b>: 다중 사용자 인터페이스에서 각 사용자마다 독립적인 상태 관리가 필요한 경우"
    }
  },
  "adaptor": {
    "title": "adaptor 함수",
    "0": "애플리케이션의 상태(state)가 여러 계층으로 이루어진 복잡한 객체 형태를 띨 때가 많습니다. 예를 들어, 사용자 프로필 정보, 설정값, 그리고 그 안에 또 다른 중첩된 객체들이 포함될 수 있습니다. 이런 상황에서 <cd>setValue</cd> 함수를 사용하여 상태의 특정 부분만 변경하려고 하면, 나머지 부분은 그대로 유지하면서 원하는 값만 업데이트하는 코드를 작성하는 것이 번거로울 수 있습니다. 불변성을 지키기 위해 전개 연산자(<cd>...</cd>)를 여러 번 사용해야 하거나, 깊은 복사를 신경 써야 하는 경우가 발생하기 때문입니다.",
    "1": "이러한 불편함을 해소하기 위해 caro-kann은 <cd>adaptor</cd> 유틸리티 함수를 제공합니다. adaptor 함수는 내부적으로 Immer 라이브러리의 product를 사용해 구현되었으며, 개발자가 상태 객체의 '초안(draft)' 버전을 직접 수정하는 것처럼 코드를 작성할 수 있게 해줍니다. 내부적으로는 불변성을 유지하면서 새로운 상태 객체를 생성해주기 때문에, 개발자는 복잡한 전개 연산자 없이도 직관적으로 상태를 업데이트할 수 있습니다."
  },
  "merge": {
    "title": "merge 함수",
    "0": "merge 함수는 여러 개의 독립적인 useStore 훅을 하나의 통합된 useStore 훅처럼 사용할 수 있도록 묶어주는 유용한 유틸리티입니다. 애플리케이션의 규모가 커지면서 상태를 기능별 또는 도메인별로 분리하여 여러 개의 작은 스토어로 관리하는 경우가 많아집니다. 예를 들어, 장바구니 상태를 관리하는 useCart 스토어와 사용자 프로필 정보를 관리하는 useUserProfile 스토어가 있을 수 있습니다.<br></br><br></br>이때 특정 컴포넌트에서 장바구니 정보와 사용자 프로필 정보가 모두 필요한 상황이 발생할 수 있습니다. merge 함수가 없다면, 해당 컴포넌트 내에서 useCart()와 useUserProfile()을 각각 호출해야 할 것입니다. 이는 컴포넌트 내에 여러 개의 상태 구독 로직이 생기게 만들어 코드를 다소 장황하게 만들 수 있습니다.",
    "1": "merge 함수는 이러한 상황을 개선하기 위해 등장했습니다. <b><i>최대 여덟 개</i></b>의 useStore 훅을 하나의 객체로 묶어 useStore와 유사한 useMergedStore 훅을 생성합니다. 이 새로운 훅을 사용하면, 단 한 번의 호출로 관련된 여러 스토어의 상태를 한 번에 가져오고, 해당 상태들을 업데이트할 수 있는 단일화된 setValue 함수를 제공받게 됩니다. 이는 '바텀업(Bottom-up)' 방식으로, 개별적으로 잘 정의된 작은 스토어들을 필요에 따라 조합하여 더 큰 상태 로직을 구성할 수 있게 해줍니다. 결과적으로 컴포넌트의 코드가 간결해지고, 상태 접근 및 관리의 일관성이 높아집니다.",
    "2": "useMergedStore는 선택자 함수나 useStore가 제공하는 readOnly와 writeOnly 메서드도 동일하게 사용할 수 있습니다. 하지만 Provider는 제공되지 않습니다. 이는 merge 함수 자체가 이미 독립적으로 생성되고 관리될 수 있는 여러 스토어 인스턴스(또는 스토어 접근 훅)를 조합하는 데 초점을 맞추고 있기 때문입니다.",
    "subtitle1": "서로 다른 미들웨어를 사용하는 스토어 병합하기",
    "3": "merge 함수의 강력한 기능 중 하나는 서로 다른 미들웨어를 사용하는 스토어들을 자유롭게 조합할 수 있다는 점입니다. 각 스토어는 자신의 요구사항에 맞는 미들웨어를 독립적으로 사용하면서도, merge를 통해 하나의 통합된 인터페이스로 관리할 수 있습니다.<br></br><br></br>다음 예시에서는 사이드바 토글 기능을 구현하면서, 데스크탑과 모바일 환경에서 서로 다른 데이터 지속성 전략을 적용합니다:",
    "4": "이렇게 병합된 스토어를 사용하면, 각각의 특성을 유지하면서도 일관된 방식으로 상태를 관리할 수 있습니다:",
    "5": "이 접근 방식의 주요 이점은 다음과 같습니다:",
    "6": "merge 함수는 이처럼 각기 다른 요구사항을 가진 상태들을 효율적으로 조합하여, 복잡한 애플리케이션에서도 일관되고 직관적인 상태 관리를 가능하게 합니다.",
    "subtitle2": "getStoreFrom",
    "7": "useSomeStore.Provider 컴포넌트 하위에서 렌더링되는, merge 함수로 생성된 병합 스토어(예: useMergedStore)는 기본적으로 각 구성 요소 스토어에 대해 가장 가까운 Provider 컨텍스트를 따릅니다. 예를 들어, useUserProfile을 포함하는 useMergedStore가 useUserProfile.Provider 내부에 있다면, useMergedStore의 userProfile 부분은 해당 Provider가 제공하는 스토어 인스턴스에서 값을 가져옵니다.<br></br><br></br>하지만 merge 함수는 두 번째 선택적 인자로 `getStoreFrom` 옵션을 받을 수 있습니다. 이 옵션은 객체 형태로, 병합에 사용된 각 useStore 키에 대해 해당 스토어가 값을 어디서 가져올지를 명시적으로 지정할 수 있게 해줍니다. 각 키에 대해 'context' 또는 'root' 값을 설정할 수 있습니다.",
    "8": "이 <cd>getStoreFrom</cd> 옵션을 통해 개발자는 병합된 스토어의 각 부분이 어떤 스코프의 상태를 참조할지 세밀하게 제어할 수 있어, 복잡한 애플리케이션 아키텍처에서 유연성을 크게 높일 수 있습니다.",

    "subtitle3": "제한 사항",
    "9": "merge 함수는 여러 useStore 훅을 편리하게 조합할 수 있는 강력한 기능을 제공하지만, 몇 가지 제한 사항을 가지고 있습니다.",
    "10": "Error: merge function can only merge up to 8 stores at a time. Please reduce the number of stores you are trying to merge.",
    "11": "이러한 제한이 있는 주된 이유는 두 가지입니다.",
    "12": "또한 merge 함수가 리턴하는 것은 useStore가 아니라 useMergedStore인 까닭에 여러 merge 결과를 다시 조합하는 것은 근본적으로 불가능합니다. 이러한 제한 사항을 이해하고 merge 함수를 사용하면, 애플리케이션의 상태 관리 구조를 효과적으로 설계하고 예기치 않은 문제를 방지하는 데 도움이 될 것입니다.",
    "list": {
      "0": "<b>적절한 데이터 지속성</b>: 데스크탑 사이드바는 사용자 선호도로 간주되어 영구 저장되고, 모바일 사이드바는 임시 UI 상태로 취급됩니다.",
      "1": "<b>유연한 아키텍처</b>: 각 스토어가 독립적으로 최적화되면서도 통합된 인터페이스를 제공합니다.",
      "2": "<b>유지보수성</b>: 필요시 개별 스토어의 미들웨어를 변경하거나 추가해도 병합된 스토어를 사용하는 컴포넌트 코드에는 영향을 주지 않습니다.",

      "3": "<b><cd>context</cd></b> (또는 옵션 생략 시 기본 동작) : 해당 useStore 부분은 가장 가까운 Provider 컨텍스트를 따릅니다. 만약 감싸는 Provider가 없다면, create로 생성된 최상위(전역) 스토어를 사용합니다.",
      "4": "<b><cd>root</cd></b> : 해당 useStore 부분은 Provider 컨텍스트의 존재 여부와 관계없이 항상 create로 생성된 최상위(전역) 스토어에서 직접 값을 가져옵니다.",

      "5": "<b>reducer 미들웨어 사용 스토어 병합 불가</b>: reducer 미들웨어를 사용하여 생성된 useStore 훅은 merge 함수를 통해 다른 스토어와 병합할 수 없습니다. 시도할 경우, 타입스크립트 환경에서는 타입 에러가 발생하여 이를 미리 방지합니다. 이는 reducer 미들웨어가 setValue 함수의 동작 방식을 근본적으로 변경하고, 상태 업데이트 로직이 일반적인 useStore와 다르기 때문입니다. merge 함수는 각 useStore가 표준적인 [value, setValue] 인터페이스를 따른다고 가정하고 동작하므로, reducer를 사용한 스토어와의 호환성 문제가 발생할 수 있습니다.",
      "6": "<b>최대 병합 개수 제한</b>: 앞서 스쳐 지나가듯 언급했던 것처럼, merge 함수는 한 번에 최대 8개의 useStore 훅까지만 병합할 수 있습니다. 8개를 초과하는 스토어를 병합하려고 하면 다음과 같은 오류가 발생합니다.",
      "7": "<b>React 훅 규칙</b>: merge 함수 내부적으로 각 useStore의 컨텍스트 값을 가져오기 위해 useContext를 사용하고 있습니다. React 훅은 반복문이나 조건문 내에서 호출될 수 없다는 규칙이 있어, 동적으로 무한한 수의 컨텍스트를 처리하는 데 제약이 따릅니다.",
      "8": "<b>성능 고려</b>: 이론적으로 더 많은 스토어를 병합할 수 있도록 구현할 수도 있겠지만, 병합하는 스토어의 수가 늘어날수록 내부적으로 처리해야 할 로직이 복잡해지고, 상태 변경 시 구독 및 업데이트 과정에서 잠재적인 성능 저하가 발생할 수 있습니다. 8개라는 제한은 사용성과 성능 사이의 균형을 고려한 결정으로 볼 수 있습니다."
    }
  }
}

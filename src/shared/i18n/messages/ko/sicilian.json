{
  "introduce": {
    "title": "sicilian을 소개합니다",
    "description": "프론트엔드 분야에서 form 상태 관리 도구로 널리 쓰이는 react-hook-form은 ref를 기반으로 동작합니다. 이 때문에 컴포넌트를 forwardRef로 감싸거나, 라이브러리에서 제공하는 useFormContext를 사용해야 합니다. React.js를 사용하는 개발자로서 이러한 제약 사항이 여러모로 불편하게 느껴졌습니다.<br></br><br></br>sicilian은 이러한 불편함을 해결하기 위해 전역 상태를 기반으로 개발되었습니다. 이는 sicilian이 각각의 input을 state로 관리하며, 제어 컴포넌트 방식으로 form을 작성하도록 도움을 줄 수 있다는 뜻이기도 합니다. Sicilian은 React의 Context API를 내부적으로 활용하여 폼 상태를 전역적으로 관리하며, 이를 통해 별도의 전역 상태 관리 라이브러리(예: Redux, Zustand) 없이도 원하는 컴포넌트 어디에서나 폼 상태에 접근하고 조작할 수 있습니다.",
    "whatsNew": "sicilian@3.1.0에서 새로 추가된 것",
    "list": {
      "0": "zod, yup, superstruct 를 사용한 런타임 유효성 검증을 지원합니다.",
      "1": "type=\"radio\"에서 register 함수가 오작동하던 버그를 수정했습니다.",
      "2": "<cd>handleValidate</cd> 대신 범용적으로 사용할 수 있는 <cd>validateOptions</cd> 함수가 추가되었습니다.",
      "3": "서버 액션을 지원하는 <cd>handleServerAction</cd> 함수가 추가되었습니다.",
      "4": "CLI를 통해 코드 스니펫을 간편하게 생성하는 기능이 추가되었습니다. 자세한 내용은 <a><cd>CLI 사용법</cd></a> 페이지를 참조하세요."
    },
    "installation": "설치 방법",
    "installationBody": "sicilian은 아래의 다양한 방법으로 설치할 수 있습니다.",
    "quickStart": "빠른 시작",
    "quickStartBody": "아래 예시는 sicilian의 기본적인 사용법을 보여줍니다. 이 예시에서는 간단한 로그인 폼을 구현하고 있으며, 이메일과 비밀번호 필드에 대한 유효성 검사를 포함하고 있습니다. sicilian의 폼 컨트롤러를 사용하여 폼 상태를 관리하고, 각 입력 필드에 대한 오류 메시지를 표시하는 방법을 확인할 수 있습니다."
  },
  "api": {
    "0": "이 페이지는 Sicilian 라이브러리의 주요 API에 대한 상세한 정보를 제공합니다. 각 함수, 컴포넌트, 훅의 매개변수, 반환 값, 타입 및 사용 예시를 확인할 수 있습니다."
  },
  "cli": {
    "title": "Sicilian CLI 사용법",
    "description": "<cd>@ilokesto/sicilian</cd>은 개발자의 생산성을 높이고 반복적인 코드 작성을 줄이기 위한 CLI(Command Line Interface) 도구를 제공합니다. CLI를 통해 빠르고 효율적으로 <cd>sicilian</cd> 코드 스니펫을 간편하게 생성하고 프로젝트에 추가할 수 있습니다.",
    "subtitle1": "help 명령어",
    "0": "<cd>help</cd> 명령어는 Sicilian CLI의 사용법과 사용 가능한 플래그 및 옵션에 대한 정보를 표시합니다.",
    "1": "또는 인자 없이 <cd>sicilian</cd> 명령어 만을 단독으로 실행할 때도 도움말이 표시됩니다.",
    "subtitle2": "generate 명령어",
    "2": "<cd>generate</cd> 명령어는 새로운 코드 스니펫을 생성하여 지정된 파일에 추가합니다.",
    "subtitle3": "1. 기본 스니펫 생성 (비구조화 할당)",
    "3": "다음 명령어를 사용하여 <cd>src/components/MyForm.tsx</cd> 에 비구조화 할당 형태의 스니펫을 생성합니다.",
    "4": "명령어 실행의 결과로 <cd>src/components/MyForm.tsx</cd> 에 다음과 같은 코드가 추가됩니다:",
    "subtitle4": "2. 객체 스니펫 생성",
    "5": "다음 명령어를 사용하여 <cd>src/utils/formHooks.ts</cd> 에 객체 형태의 스니펫을 생성합니다.",
    "6": "명령어 실행의 결과로 <cd>src/utils/formHooks.ts</cd> 에 다음과 같은 코드가 추가됩니다:",
    "list": {
      "0": "<cd>'<'file_path'>'</cd>: 스니펫을 생성할 파일의 경로를 지정합니다. 파일이 존재하지 않으면 새로 생성되고, 이미 존재하면 스니펫이 파일 끝에 추가됩니다. 필요한 경우 상위 디렉토리도 자동으로 생성됩니다.",
      "1": "<cd>-o, --object</cd>: 객체 형태의 스니펫을 생성합니다. 이 옵션을 사용하지 않으면 기본적으로 비구조화 할당 형태의 스니펫이 생성됩니다."
    }
  },
  "tutorials": {
    "title": "튜토리얼: 세 가지 폼 패턴 이해하기",
    "0": "프론트엔드에서 form은 유저의 입력을 받아 처리하는 가장 기본적인 수단입니다. 그러나 단순히 입력값을 받는 것만으로는 충분하지 않습니다. 어떤 입력을 받아야 하는지, 입력값이 언제 어떻게 변할 수 있는지를 고민하는 것은 form 설계에서 매우 중요한 일입니다. 그렇기 때문에 form의 구조와 동작 방식을 체계적으로 분류할 필요가 있습니다.<br></br><br></br>sicilian은 이러한 문제의식에서 출발하여, 프론트엔드에서 작성되는 form을 세 가지 형태로 구분합니다. 각각은 <b>static form</b>, <b>dynamic form</b>, 그리고 <b>dynamic input</b>으로, form 자체가 정적인지 혹은 동적인지, 그리고 form을 구성하는 input이 정적인지 동적인지에 따라 구분됩니다. 아래 표는 이 세 가지 형태의 분류 기준을 요약한 것입니다.",
    "1": "각 형태의 form이 어떤 구조와 특징을 가지는지는 이후에 자세히 살펴보겠습니다. 우선, 프론트엔드에서 가장 일반적으로 사용되는 형태인 static form을 sicilian으로 구현해보며 form 관리의 기본 원리를 이해해보겠습니다.",
    "static": {
      "0": "정적 서식은 form이 어떤 특정 조건에 의해 생성되거나 하지 않으며, 내부의 input 종류도 고정적인 경우를 말합니다. 정적 서식의 대표적인 예시는 회원가입 form입니다. 이는 언제나 회원가입 버튼을 눌러 들어간 페이지에 존재하며, 그 구조도 email, password, nickname 등으로 늘 고정되어있습니다. 비슷하게 게시글 작성 form도 게시글 작성 페이지에 언제나 존재하며, 그 구조 역시 title, content, tags 등으로 고정되어있습니다.<br></br><br></br>이런 정적 서식을 작성할 때 저는 CreateForm에 initValue 혹은 validator 프로퍼티를 제공함으로써 타입 안전하게 form을 관리하도록 권합니다. CreateForm을 사용하면 컴포넌트 외부에서 form을 정의할 수 있습니다.",
      "1": "이렇게 form의 스펙을 외부에서 정의하게 되면, 관심사의 분리가 명확해집니다. UI 컴포넌트와 폼 검증 로직이 분리되어 각 부분이 자신의 역할에만 집중할 수 있습니다. 폼의 복잡한 유효성 검사 규칙은 컴포넌트 외부에서 관리되므로, 컴포넌트 자체는 사용자 인터페이스에만 집중할 수 있습니다.<br></br><br></br>또한, 코드 가독성 측면에서도 큰 이점이 있습니다. 컴포넌트 내부가 복잡한 유효성 검사 로직으로 채워지지 않아 전체적인 구조를 파악하기 쉬워집니다. 실제 사용 예시를 보면 컴포넌트 코드가 간결하고 선언적이며, 폼 필드의 정의와 렌더링 로직이 명확하게 구분됩니다."
    },
    "dynamic": {
      "0": "그러나 모든 form이 정적 서식일 수는 없습니다. 어떤 form은 조건부로 나타나고 사라집니다. 예를 들면 댓글 form이 그렇습니다. 유튜브의 댓글 form을 생각해보면 1) 대댓글 버튼을 누르기 전에는 대댓글 form이 나타나지 않고, 2) 수정 버튼을 누르면 그 자리에 댓글 form이 나타나며, 3) 댓글, 대댓글, 댓글 수정 모두 동일한 구조를 가지고 있습니다. 이처럼 form의 생성은 조건적이지만 그 내부의 구조는 고정적인 경우를 sicilian은 동적 서식이라고 부릅니다.<br></br><br></br>이런 동적 서식을 작성할 때는 CreateForm을 사용할 수 없습니다. form의 생애주기가 컴포넌트와 함께 해야하기 때문입니다. 그래서 sicilian은 동적 서식을 위한 useForm을 제공합니다. useForm을 사용하면 컴포넌트 내부에서 form을 정의할 수 있습니다."
    },
    "custom": {
      "0": "정적 서식은 form의 존재와 input 구조가 정적이며, 동적 서식은 form의 존재가 동적이지만 input 구조는 정적입니다. 마지막으로 알아볼 사용자 정의 서식은 동적 서식과는 반대로 form의 존재는 정적이지만 input 구조가 동적입니다. 사용자 정의 서식에 대한 일반적인 오해는 이렇습니다. '이름을 입력하면 전화번호 input이 생기고, 전화번호를 입력하면 인증 번호 input이 생기는' 개인 정보 form은 사용자 정의 서식이 아니라 정적 서식입니다.<br></br><br></br>다시 한 번 정적 서식의 정의를 살펴보면 \"form의 존재와 input 구조가 정적\"이라는 것입니다. 개인 정보 form은 그 존재가 정적이며, input이 동적으로 드러납니다. 그럼에도 불구하고 input의 구조는 늘 name gender phoneNumber phoneNumberValidateNumber 등으로 고정되어있기 때문에 사용자 정의 서식이 아니라 정적 서식이 되는 것입니다.<br></br><br></br>그렇다면 어떤 것이 사용자 정의 서식이 될 수 있을까요? 할 일 목록 form은 전형적인 사용자 정의 서식의 예시입니다. input 개수가 정해져있지 않고 사용자의 필요에 따라 늘어날 수도, 줄어들 수도 있기 때문입니다.",
      "1": "사실 위의 예시 코드는 동작하지 않습니다. 정확히는 랜더링은 되지만, Add todo 버튼을 클릭하면 \"Error: Rendered more hooks than during the previous render.\" 에러가 발생합니다. 이는 register 함수와 getErrors 함수 내부에 리액트 훅이 존재하기 때문입니다. 리액트에서는 컴포넌트 내부의 훅 갯수를 항상 동일하게 유지해주어야 합니다(훅을 조건부로 호출하지 말라는 훅의 규칙도 이를 위해 존재하는 것입니다). 그런데 input이 늘어나면 그만큼 register 함수와 getErrors 함수를 더 많이 호출하게 되므로 이전 렌더와 비교하여 더 많은 훅이 호출됩니다.<br></br><br></br>따라서 사용자 정의 서식을 작성할 때는 SicilianProvider와 useSicilianContext를 통해 관련 함수를 자식 컴포넌트에서 호출되도록 해야 문제가 생기지 않습니다."
    }
  }
}

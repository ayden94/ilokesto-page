{
  "introduce": {
    "title": "sicilian을 소개합니다",
    "description": "프론트엔드 분야에서 form 상태 관리 도구로 널리 쓰이는 react-hook-form은 ref를 기반으로 동작합니다. 이 때문에 컴포넌트를 forwardRef로 감싸거나, 라이브러리에서 제공하는 useFormContext를 사용해야 합니다. React.js를 사용하는 개발자로서 이러한 제약 사항이 여러모로 불편하게 느껴졌습니다.<br></br><br></br>sicilian은 이러한 불편함을 해결하기 위해 전역 상태를 기반으로 개발되었습니다. 이는 sicilian이 각각의 input을 state로 관리하며, 제어 컴포넌트 방식으로 form을 작성하도록 도움을 줄 수 있다는 뜻이기도 합니다. Sicilian은 React의 Context API를 내부적으로 활용하여 폼 상태를 전역적으로 관리하며, 이를 통해 별도의 전역 상태 관리 라이브러리(예: Redux, Zustand) 없이도 원하는 컴포넌트 어디에서나 폼 상태에 접근하고 조작할 수 있습니다.",
    "whatsNew": "sicilian@3.1.0에서 새로 추가된 것",
    "list": {
      "0": "zod, yup, superstruct 를 사용한 런타임 유효성 검증을 지원합니다.",
      "1": "type=\"radio\"에서 register 함수가 오작동하던 버그를 수정했습니다.",
      "2": "<cd>handleValidate</cd> 대신 범용적으로 사용할 수 있는 <cd>validateOptions</cd> 함수가 추가되었습니다.",
      "3": "서버 액션을 지원하는 <cd>handleServerAction</cd> 함수가 추가되었습니다.",
      "4": "CLI를 통해 코드 스니펫을 간편하게 생성하는 기능이 추가되었습니다. 자세한 내용은 <a><cd>CLI 사용법</cd></a> 페이지를 참조하세요."
    },
    "installation": "설치 방법",
    "installationBody": "sicilian은 아래의 다양한 방법으로 설치할 수 있습니다.",
    "quickStart": "빠른 시작",
    "quickStartBody": "아래 예시는 sicilian의 기본적인 사용법을 보여줍니다. 이 예시에서는 간단한 로그인 폼을 구현하고 있으며, 이메일과 비밀번호 필드에 대한 유효성 검사를 포함하고 있습니다. sicilian의 폼 컨트롤러를 사용하여 폼 상태를 관리하고, 각 입력 필드에 대한 오류 메시지를 표시하는 방법을 확인할 수 있습니다."
  },
  "api": {
    "0": "이 페이지는 Sicilian 라이브러리의 주요 API에 대한 상세한 정보를 제공합니다. 각 함수, 컴포넌트, 훅의 매개변수, 반환 값, 타입 및 사용 예시를 확인할 수 있습니다."
  },
  "cli": {
    "title": "Sicilian CLI 사용법",
    "description": "<cd>@ilokesto/sicilian</cd>은 개발자의 생산성을 높이고 반복적인 코드 작성을 줄이기 위한 CLI(Command Line Interface) 도구를 제공합니다. CLI를 통해 빠르고 효율적으로 <cd>sicilian</cd> 코드 스니펫을 간편하게 생성하고 프로젝트에 추가할 수 있습니다.",
    "subtitle1": "help 명령어",
    "0": "<cd>help</cd> 명령어는 Sicilian CLI의 사용법과 사용 가능한 플래그 및 옵션에 대한 정보를 표시합니다.",
    "1": "또는 인자 없이 <cd>sicilian</cd> 명령어 만을 단독으로 실행할 때도 도움말이 표시됩니다.",
    "subtitle2": "generate 명령어",
    "2": "<cd>generate</cd> 명령어는 새로운 코드 스니펫을 생성하여 지정된 파일에 추가합니다.",
    "subtitle3": "1. 기본 스니펫 생성 (비구조화 할당)",
    "3": "다음 명령어를 사용하여 <cd>src/components/MyForm.tsx</cd> 에 비구조화 할당 형태의 스니펫을 생성합니다.",
    "4": "명령어 실행의 결과로 <cd>src/components/MyForm.tsx</cd> 에 다음과 같은 코드가 추가됩니다:",
    "subtitle4": "2. 객체 스니펫 생성",
    "5": "다음 명령어를 사용하여 <cd>src/utils/formHooks.ts</cd> 에 객체 형태의 스니펫을 생성합니다.",
    "6": "명령어 실행의 결과로 <cd>src/utils/formHooks.ts</cd> 에 다음과 같은 코드가 추가됩니다:",
    "list": {
      "0": "<cd>'<'file_path'>'</cd>: 스니펫을 생성할 파일의 경로를 지정합니다. 파일이 존재하지 않으면 새로 생성되고, 이미 존재하면 스니펫이 파일 끝에 추가됩니다. 필요한 경우 상위 디렉토리도 자동으로 생성됩니다.",
      "1": "<cd>-o, --object</cd>: 객체 형태의 스니펫을 생성합니다. 이 옵션을 사용하지 않으면 기본적으로 비구조화 할당 형태의 스니펫이 생성됩니다."
    }
  },
  "tutorials": {
    "title": "튜토리얼: 세 가지 폼 패턴 이해하기",
    "0": "프론트엔드에서 form은 유저의 입력을 받아 처리하는 가장 기본적인 수단입니다. 그러나 단순히 입력값을 받는 것만으로는 충분하지 않습니다. 어떤 입력을 받아야 하는지, 입력값이 언제 어떻게 변할 수 있는지를 고민하는 것은 form 설계에서 매우 중요한 일입니다. 그렇기 때문에 form의 구조와 동작 방식을 체계적으로 분류할 필요가 있습니다.<br></br><br></br>sicilian은 이러한 문제의식에서 출발하여, 프론트엔드에서 작성되는 form을 세 가지 형태로 구분합니다. 각각은 <b>static form</b>, <b>dynamic form</b>, 그리고 <b>dynamic input</b>으로, form 자체가 정적인지 혹은 동적인지, 그리고 form을 구성하는 input이 정적인지 동적인지에 따라 구분됩니다. 아래 표는 이 세 가지 형태의 분류 기준을 요약한 것입니다.",
    "1": "각 형태의 form이 어떤 구조와 특징을 가지는지는 이후에 자세히 살펴보겠습니다. 우선, 프론트엔드에서 가장 일반적으로 사용되는 형태인 static form을 sicilian으로 구현해보며 form 관리의 기본 원리를 이해해보겠습니다.",
    "static": {
      "0": "정적 서식은 form이 어떤 특정 조건에 의해 생성되거나 하지 않으며, 내부의 input 종류도 고정적인 경우를 말합니다. 정적 서식의 대표적인 예시는 회원가입 form입니다. 이는 언제나 회원가입 버튼을 눌러 들어간 페이지에 존재하며, 그 구조도 email, password, nickname 등으로 늘 고정되어있습니다. 비슷하게 게시글 작성 form도 게시글 작성 페이지에 언제나 존재하며, 그 구조 역시 title, content, tags 등으로 고정되어있습니다.<br></br><br></br>이런 정적 서식을 작성할 때 저는 CreateForm에 initValue 혹은 validator 프로퍼티를 제공함으로써 타입 안전하게 form을 관리하도록 권합니다. CreateForm을 사용하면 컴포넌트 외부에서 form을 정의할 수 있습니다.",
      "1": "이렇게 form의 스펙을 외부에서 정의하게 되면, 관심사의 분리가 명확해집니다. UI 컴포넌트와 폼 검증 로직이 분리되어 각 부분이 자신의 역할에만 집중할 수 있습니다. 폼의 복잡한 유효성 검사 규칙은 컴포넌트 외부에서 관리되므로, 컴포넌트 자체는 사용자 인터페이스에만 집중할 수 있습니다.<br></br><br></br>또한, 코드 가독성 측면에서도 큰 이점이 있습니다. 컴포넌트 내부가 복잡한 유효성 검사 로직으로 채워지지 않아 전체적인 구조를 파악하기 쉬워집니다. 실제 사용 예시를 보면 컴포넌트 코드가 간결하고 선언적이며, 폼 필드의 정의와 렌더링 로직이 명확하게 구분됩니다."
    },
    "dynamic": {
      "0": "그러나 모든 form이 정적 서식일 수는 없습니다. 어떤 form은 조건부로 나타나고 사라집니다. 예를 들면 댓글 form이 그렇습니다. 유튜브의 댓글 form을 생각해보면 1) 대댓글 버튼을 누르기 전에는 대댓글 form이 나타나지 않고, 2) 수정 버튼을 누르면 그 자리에 댓글 form이 나타나며, 3) 댓글, 대댓글, 댓글 수정 모두 동일한 구조를 가지고 있습니다. 이처럼 form의 생성은 조건적이지만 그 내부의 구조는 고정적인 경우를 sicilian은 동적 서식이라고 부릅니다.<br></br><br></br>이런 동적 서식을 작성할 때는 CreateForm을 사용할 수 없습니다. form의 생애주기가 컴포넌트와 함께 해야하기 때문입니다. 그래서 sicilian은 동적 서식을 위한 useForm을 제공합니다. useForm을 사용하면 컴포넌트 내부에서 form을 정의할 수 있습니다."
    },
    "custom": {
      "0": "정적 서식은 form의 존재와 input 구조가 정적이며, 동적 서식은 form의 존재가 동적이지만 input 구조는 정적입니다. 마지막으로 알아볼 사용자 정의 서식은 동적 서식과는 반대로 form의 존재는 정적이지만 input 구조가 동적입니다. 사용자 정의 서식에 대한 일반적인 오해는 이렇습니다. '이름을 입력하면 전화번호 input이 생기고, 전화번호를 입력하면 인증 번호 input이 생기는' 개인 정보 form은 사용자 정의 서식이 아니라 정적 서식입니다.<br></br><br></br>다시 한 번 정적 서식의 정의를 살펴보면 \"form의 존재와 input 구조가 정적\"이라는 것입니다. 개인 정보 form은 그 존재가 정적이며, input이 동적으로 드러납니다. 그럼에도 불구하고 input의 구조는 늘 name gender phoneNumber phoneNumberValidateNumber 등으로 고정되어있기 때문에 사용자 정의 서식이 아니라 정적 서식이 되는 것입니다.<br></br><br></br>그렇다면 어떤 것이 사용자 정의 서식이 될 수 있을까요? 할 일 목록 form은 전형적인 사용자 정의 서식의 예시입니다. input 개수가 정해져있지 않고 사용자의 필요에 따라 늘어날 수도, 줄어들 수도 있기 때문입니다.",
      "1": "사실 위의 예시 코드는 동작하지 않습니다. 정확히는 랜더링은 되지만, Add todo 버튼을 클릭하면 \"Error: Rendered more hooks than during the previous render.\" 에러가 발생합니다. 이는 register 함수와 getErrors 함수 내부에 리액트 훅이 존재하기 때문입니다. 리액트에서는 컴포넌트 내부의 훅 갯수를 항상 동일하게 유지해주어야 합니다(훅을 조건부로 호출하지 말라는 훅의 규칙도 이를 위해 존재하는 것입니다). 그런데 input이 늘어나면 그만큼 register 함수와 getErrors 함수를 더 많이 호출하게 되므로 이전 렌더와 비교하여 더 많은 훅이 호출됩니다.<br></br><br></br>따라서 사용자 정의 서식을 작성할 때는 SicilianProvider와 useSicilianContext를 통해 관련 함수를 자식 컴포넌트에서 호출되도록 해야 문제가 생기지 않습니다."
    }
  },
  "guides": {
    "create": {
      "title": "formController 객체 만들기",
      "0": "sicilian은 form을 관리하기 위한 도구 모음을 <cd>formController</cd>라고 부릅니다. 이 객체는 <cd>CreateForm</cd> 클래스와 <cd>useForm</cd> 훅을 통해 얻을 수 있습니다. CreateForm 클래스와 useForm 훅은 컴포넌트와 생애주기를 함께하는지 아닌지의 차이만 있을 뿐 본질적으로 동일합니다. 이 둘은 모두 <cd>formController</cd>를 초기화하는 '초기화 객체'를 인자로 받습니다. 초기화 객체는 <cd>initValue</cd>, <cd>resolver</cd>, <cd>validator</cd>, <cd>validateOn</cd>, <cd>clearFormOn</cd>으로 이루어져있으며, 모든 프로퍼티는 옵셔널하게 제공할 수 있습니다.",
      "1": "<cd>initValue</cd> props는 input에 초기값을 제공하기 위해 사용됩니다. 이 속성을 통해 폼 필드의 초기 상태를 정의할 수 있으며, 각 필드의 데이터 타입도 함께 지정됩니다. TypeScript를 사용할 경우, <cd>initValue</cd>에 정의된 객체 구조를 기반으로 타입 추론이 이루어져 타입 안전성을 확보할 수 있습니다. 초기값은 빈 문자열, 기본값, 혹은 API에서 가져온 데이터 등으로 설정할 수 있으며, 체크박스나 라디오 버튼과 같은 컨트롤에도 기본 상태를 지정할 수 있습니다. 예시 코드에서 볼 수 있듯이, 모든 관련 필드를 포함한 객체 형태로 제공됩니다.",
      "2": "<cd>resolver</cd> props는 폼 데이터의 유효성 검사를 위한 강력한 도구로, 선언적인 방식으로 복잡한 검증 규칙을 정의할 수 있게 해줍니다. 아래 예제에서는 <cd>zodResolver</cd>를 통해 <cd>zod</cd> 라이브러리의 스키마 기반 검증 기능을 sicilian과 통합하고 있습니다. 이메일 형식 검증, 문자열 길이 제한, 비밀번호 복잡성 요구사항, 필수 필드 검증 등 다양한 규칙을 명확하게 정의할 수 있습니다. 특히 <cd>.refine()</cd> 메소드를 사용하면 비밀번호 일치 여부 확인과 같은 필드 간 관계 검증도 가능합니다. 이러한 선언적 접근 방식은 코드의 가독성을 높이고 유지보수를 쉽게 만듭니다.",
      "3": "<cd>validator</cd> 객체는 각 폼 필드에 대한 개별적이고 세부적인 유효성 검사 규칙을 정의합니다. 이는 <cd>resolver</cd>와 함께 사용하거나 독립적으로 사용할 수 있어 더 유연한 폼 검증이 가능합니다. 각 필드마다 필요한 검증 규칙을 상세하게 정의할 수 있으며, 사용자 입력에 따른 동적 검증이나 조건부 검증에 특히 유용합니다.<br></br><br></br><cd>validator</cd> 객체를 통한 유효성 검증 방법 및 검증 순서 등에 대해서는 <a><cd>resolver와 validator</cd></a> 에서 더 자세히 알아볼 것입니다.",
      "4": "validateOn props는 유효성 검사가 실행되는 시점을 제어합니다. 이 배열에는 <cd>change</cd>, <cd>blur</cd>, <cd>submit</cd> 세 가지 이벤트 유형을 조합하여 지정할 수 있으며, 각각의 이벤트 시점에 유효성 검사를 수행할지를 결정합니다. <cd>change</cd>는 사용자가 입력 필드의 값을 변경할 때마다 즉시 검증하여 실시간 피드백을 제공합니다. <cd>blur</cd>는 사용자가 필드에서 포커스가 벗어날 때 검증하여 불필요한 오류 메시지 노출을 줄입니다. <cd>submit</cd>은 폼 제출 시점에 최종 검증을 수행합니다. 이 세 가지 검증 시점을 적절히 조합하면 즉각적인 피드백과 원활한 사용자 경험 사이의 균형을 맞출 수 있습니다.",
      "5": "useForm 훅과 달리 CreateForm 클래스로부터 만들어지는 formController는 컴포넌트와 생애주기를 함께하지 않습니다. 이는 CreateForm으로 생성된 컨트롤러가 컴포넌트가 언마운트되어도 메모리에 남아있어 데이터가 유지된다는 것을 의미합니다. 따라서 clearFormOn 속성은 이러한 상황에서 폼 데이터를 적절히 초기화하는 시점을 지정하는 중요한 역할을 합니다.<br></br><br></br><cd>submit</cd>으로 설정하면 폼 제출 후 데이터가 초기화되고, <cd>routeChange</cd>로 설정하면 페이지 이동 시 자동으로 초기화됩니다. 특히 여러 페이지에 걸쳐 폼 컨트롤러를 공유하는 경우나 싱글톤 패턴으로 폼 컨트롤러를 사용할 때 이 속성을 적절히 설정하는 것이 중요합니다. 이렇게 함으로써 사용자가 다시 폼으로 돌아올 때 이전 입력 데이터가 남아있지 않도록 관리할 수 있습니다.<br></br><br></br>현재 <cd>routeChange</cd> 옵션은 React Router와 Next.js의 Page Router 및 App Router 환경에서만 정상적으로 동작합니다."
    },
    "tools": {
      "title": "formController 객체의 도구들",
      "0": "<cd>formController</cd> 객체에는 form을 관리하기 위한 다양한 메서드가 들어있습니다. 이 메서드들은 각각 특정한 역할을 담당하며 함께 동작하여 폼의 전체 생명주기를 관리합니다. <cd>register</cd> 함수는 입력 필드를 등록하고 이벤트 핸들러를 자동으로 연결하며, <cd>getValues</cd>와 <cd>getErrors</cd>는 현재 폼 상태와 오류 정보를 읽어올 수 있게 합니다. <cd>setValues</cd>와 <cd>setErrors</cd>를 통해 외부 데이터를 주입하거나 상태를 직접 제어할 수 있고, <cd>handleSubmit</cd>은 폼 제출 시 데이터 유효성을 검증하고 성공 시에만 콜백 함수를 실행합니다. 이러한 도구들을 활용하면 복잡한 폼 로직을 선언적이고 체계적으로 관리할 수 있어 개발 생산성과 코드 품질을 모두 향상시킬 수 있습니다.",
      "1": "<cd>register</cd> 함수는 폼 필드를 Sicilian 폼 컨트롤러에 등록하고 필요한 이벤트 핸들러를 자동으로 연결하는 핵심 기능입니다. 아래 타입 정의에서 볼 수 있듯이, 다양한 입력 유형을 지원하며 특히 타입스크립트 환경에서 타입 안전성을 제공합니다. <cd>ExtractKeys&lt;T&gt;</cd> 버전은 <cd>initValue</cd>나 <cd>validator</cd>에 정의된 필드명만 허용하여 오타나 존재하지 않는 필드를 사용할 수 없게 합니다. 반면 <cd>string</cd> 버전은 동적으로 필드를 추가할 때 유연성을 제공합니다. <cd>radio</cd> 타입은 일반 입력 필드와 달리 <cd>value</cd> 속성이 필수적으로 요구되며, 이를 통해 동일한 <cd>name</cd>을 가진 여러 radio 버튼을 구분합니다. 또한 각 필드에 <cd>validate</cd> 객체를 선택적으로 제공하여 개별적인 유효성 검사 규칙을 적용할 수 있습니다.",
      "2": "<cd>register</cd> 함수가 반환하는 <cd>IRegister</cd> 인터페이스는 리액트 입력 요소와 통합할 수 있는 이벤트 핸들러와 속성들을 제공합니다. <cd>onChange</cd>, <cd>onBlur</cd>, <cd>onFocus</cd> 핸들러는 각각 입력값 변경, 포커스 해제, 포커스 획득 시 폼 상태를 업데이트하고 필요에 따라 유효성 검사를 실행합니다. 특히 <cd>SicilianEvent</cd> 타입을 사용하여 일반적인 DOM 이벤트뿐 아니라 커스텀 이벤트 객체도 처리할 수 있습니다. <cd>name</cd>과 <cd>id</cd> 속성은 필드 식별자로 작용하며, <cd>type</cd> 속성은 HTML 입력 요소의 타입을 지정합니다. 또한 체크박스나 라디오 버튼 같은 요소를 위한 <cd>checked</cd> 속성과 select 요소 등을 위한 <cd>value</cd> 속성도 필요에 따라 제공됩니다. 이 모든 프로퍼티는 스프레드 연산자<cd>'{'...register('{' name: \"email\" '}')'}'</cd>를 통해 JSX 요소에 간편하게 적용할 수 있어 보일러플레이트 코드를 대폭 줄여줍니다.",
      "3": "<cd>formController</cd>는 입력 필드의 현재 값과 오류 상태에 접근하고 관리할 수 있는 다양한 메서드를 제공합니다. <cd>getValues</cd>는 폼의 모든 필드 값을 가져오거나 특정 필드의 값만 선택적으로 가져올 수 있으며, <cd>getErrors</cd>는 각 필드에 연결된 현재 오류 메시지를 조회합니다. 이 두 함수는 상태를 구독하는 방식으로 동작하여 값이 변경될 때마다 컴포넌트가 자동으로 리렌더링됩니다. <cd>setStore</cd>와 <cd>getStore</cd>는 더 낮은 수준에서 폼 상태 저장소에 직접 접근할 수 있게 해주어 복잡한 상태 관리 시나리오에서 유용합니다. 이러한 도구들을 통해 개발자는 폼 데이터를 읽고 수정하는 작업을 세밀하게 제어할 수 있으며, 외부 API로부터 받아온 데이터로 폼을 초기화하거나 특정 조건에 따라 값을 동적으로 업데이트하는 등의 고급 사용 사례를 구현할 수 있습니다.<br></br><br></br><cd>getValues</cd>와 <cd>getErrors</cd>가 리턴하는 객체는 전역 상태 그 자체이기 때문에, Context API의 리랜더링 방식과 유사한 구조적 문제를 안고 있습니다. 즉, input의 상태를 아무리 잘 격리해두었다 해도 부모 컴포넌트에 <cd>getValues</cd> 객체가 있다면 부모 컴포넌트 전체가 리랜더링됩니다. 이 문제를 해결하기 위해 <cd>getValues</cd> 함수와 <cd>getErrors</cd> 함수는 전역 상태로부터 일부만을 구독할 수 있도록 selecting name을 인자로 받습니다. 인자 없이 호출하면 전체 폼 상태 또는 오류 객체를 반환하며, 특정 필드 이름을 인자로 전달하면 해당 필드의 값이나 오류만 반환합니다.",
      "4": "<cd>setValues</cd>와 <cd>setErrors</cd>는 각각 폼 값과 오류 상태를 부분적으로 업데이트할 수 있게 해주며, 이러한 유연한 API 설계 덕분에 전체 폼 상태를 한번에 조회하거나 특정 필드만 선택적으로 관찰할 수 있어 성능 최적화에 도움이 됩니다.",
      "5": "<cd>handleSubmit</cd> 함수는 콜백 함수를 인자로 받습니다. 이 콜백 함수는 <cd>onSubmit</cd>이 발생한 시점의 전체 <cd>formState</cd>와 이벤트 객체를 인자로 받습니다. 또한 내부적으로 <cd>e.preventDefault()</cd> 처리가 되어있어 form submit으로 인한 리다이렉트가 발생하지 않습니다.",
      "6": "<cd>getValues</cd> 메소드로부터 전체 <cd>formState</cd>를 받아와 직접 submit 로직을 구현할 수도 있습니다. 하지만 <cd>handleSubmit</cd>을 사용하면 몇 가지 이점을 얻을 수 있습니다.",
      "7": "<cd>clearFormOn: [\"submit\"]</cd> 옵션이 제공된 상태라도 submit에 실패했다면 form이 초기화되지 않습니다.",
      "8": "<cd>handleServerAction</cd> 메서드는 서버 액션 혹은 서버 함수라고 불리는 상호작용을 처리하며, 폼 데이터 전송 및 응답 처리를 포함합니다. 이 메서드는 서버 측에서 실행되는 비동기 함수와 통합되어, 폼 제출 시점에 서버로 데이터를 전송하고, 서버로부터의 응답을 처리할 수 있도록 설계되었습니다. <br></br><br></br>사용자는 <cd>handleServerAction</cd> 메서드에 서버 액션 함수를 인자로 전달하며, 이 함수는 폼 데이터와 이벤트 객체를 받아 서버와의 통신을 수행합니다. 이 과정에서 폼 데이터의 유효성 검사가 자동으로 이루어지며, 검증에 실패할 경우 서버 액션이 호출되지 않습니다. 또한, 이 메서드는 서버로부터의 응답을 처리하는 콜백 함수를 추가로 인자로 받을 수 있어, 성공적인 응답이나 오류 상황에 대한 후속 작업을 쉽게 구현할 수 있습니다.",
      "9": "일반적인 서버 액션 함수는 FormData 객체를 인자로 받습니다. 하지만 handleServerAction 메서드는 폼 데이터를 객체 형태로 변환하여 전달합니다. 이는 서버 액션 함수 내에서 폼 데이터를 보다 직관적으로 다룰 수 있게 해주며, FormData 객체를 직접 조작하는 번거로움을 줄여줍니다. 또한, 이벤트 객체도 함께 전달되어 폼 제출과 관련된 추가적인 컨텍스트 정보를 활용할 수 있습니다.",
      "10": "이러한 설계를 통해 <cd>handleServerAction</cd> 메서드는 폼 제출과 서버 통신을 간소화하고, 개발자가 서버와의 상호작용을 보다 효율적으로 관리할 수 있도록 돕습니다.",
      "list": {
        "0": "만약 해결되지 않은 에러 메세지가 하나라도 남아있다면 <cd>handleSubmit</cd>은 submit을 중지시킵니다. 이를 통해 원치 않는 값이 백엔드로 가는 것을 방지할 수 있습니다.",
        "1": "비슷하게, <cd>formController</cd>가 관리하는 input이 모두 비어있는 경우에도 submit을 중지시킵니다. 따라서 유저가 실수로 submit 버튼을 눌러도 http 통신이 발생하지 않습니다."
      }
    },
    "validate": {
      "title": "resolver와 validator",
      "subtitle": "검증 우위와 검증 순서",
      "0": "CreateForm 클래스와 useForm 훅은 resolver와 validator라는 프로퍼티를 통해 form의 유효성을 검사합니다. resolver는 zod, yup, superstruct를 통해 유효성을 검사하며, validator는 sicilian에 내장된 required, checked, minLength, maxLength, RegExp, custom 등의 다양한 검증 시스템을 사용합니다.<br></br><br></br>두 방식은 함께 사용하거나 독립적으로 사용할 수 있어 유연성이 높으며, 특히 validator는 검증 우선순위와 순서에 따라 세부적인 검증 흐름을 제어할 수 있는 장점이 있습니다. 반드시 기억해야 할 점은 <b>두 방식을 함께 사용할 경우 resolver를 모두 통과해야  validator로 검증이 넘어간다</b>는 것입니다. 즉, resolver에서 유효성 검사에 실패하면 validator의 검증 로직은 실행되지 않습니다. 이러한 구조는 zod나 yup과 같은 스키마 기반 검증으로 기본적인 데이터 형식과 조건을 먼저 확인한 후, 더 복잡하거나 동적인 검증 로직은 validator로 처리하는 계층적 접근을 가능하게 합니다. 따라서 폼 설계 시 두 검증 시스템 간의 역할 분담을 명확히 하는 것을 권장합니다.",
      "1": "validator와 validate는 일견 비슷하게 느껴지지만 실제로는 구조와 용도에서 명확한 차이가 있습니다.",
      "2": "즉, validator는 '무엇을 검증할 것인가'를 정의하는 폼 전체의 검증 맵이고, validate는 '어떻게 검증할 것인가'를 정의하는 개별 필드의 검증 규칙입니다. 이러한 계층 구조 덕분에 폼 전체의 유효성 검사를 체계적으로 관리할 수 있으며, 필요에 따라 register 함수에서 개별적인 검증 로직을 적용하거나 재정의할 수 있습니다.",
      "3": "required 속성은 입력 필드가 반드시 값을 가져야 하는지를 검증합니다. boolean 값으로 간단히 지정하거나 <cd>'{' required: boolean, message: string '}'</cd> 형태의 객체로 상세하게 정의할 수 있습니다. boolean만 지정할 경우 기본 오류 메시지가 사용되며, 객체 형태로 지정하면 사용자 정의 오류 메시지를 표시할 수 있습니다. 이 속성은 validator 객체의 첫 부분에 배치하여 다른 검증 규칙보다 먼저 실행되도록 하는 것이 일반적이며, 값이 비어있을 경우 후속 검증이 실행되지 않도록 합니다.",
      "4": "minLength와 maxLength 속성은 입력 문자열의 길이를 검증합니다. 두 속성 모두 단순 숫자값으로 간단히 지정하거나 <cd>'{' number: number, message: string '}'</cd> 형태의 객체로 상세하게 정의할 수 있습니다. 숫자만 지정하면 기본 오류 메시지가 사용되고, 객체 형태를 사용하면 사용자 정의 오류 메시지를 표시합니다. minLength는 최소 글자 수를, maxLength는 최대 글자 수를 검증하며, 비밀번호 복잡도 요구사항이나 사용자 이름 길이 제한 같은 사용자 입력 제한에 유용합니다.",
      "5": "checked 속성은 체크박스와 같은 요소가 선택되었는지 여부를 검증합니다. boolean 값으로 간단히 지정하거나 <cd>'{' checked: boolean, message: string '}'</cd> 형태의 객체로 상세하게 정의할 수 있습니다. boolean만 지정할 경우 기본 오류 메시지가 사용되고, 객체 형태를 사용하면 사용자 정의 오류 메시지를 표시합니다. 이 속성은 이용약관 동의, 마케팅 수신 동의 등 사용자의 명시적 동의가 필요한 체크박스에 주로 사용되며, 반드시 선택되어야 하는 경우 checked: true로 설정합니다.",
      "6": "RegExp와 custom 모두 검증 객체 뿐 아니라 검증 객체로 이루어진 배열을 받습니다. 덕분에 input 값을 여러 방면으로 검증해볼 수 있습니다. 앞서 살펴본 required, minLength, maxLength, checked와는 달리 RegExp와 custom를 사용할 때는 오류 메세지를 반드시 넣어줄 필요가 없으며, 메시지를 생략할 경우 검증 실패 시 기본 오류 메시지가 표시됩니다. RegExp는 정규표현식을 사용하여 입력값의 패턴을 검증하는 데 특화되어 있고, custom은 개발자가 정의한 함수를 통해 보다 복잡하고 동적인 검증 로직을 구현할 수 있습니다. 배열 형태로 여러 검증 규칙을 제공하면 Sicilian은 이들을 순차적으로 검증하고, 첫 번째 실패한 규칙에서 검증 프로세스를 중단하고 해당 오류 메시지를 표시합니다.",
      "7": "custom에 사용되는 콜백함수 checkFn은 input value와 전체 formState를 인자로 받아 검증 로직을 수행한 후 boolean 값을 반환합니다. 이 <b>결과가 true이면 오류가 발생하고, false이면 유효성 검사를 통과</b>합니다. RegExp와 마찬가지로 여러 검증 객체를 배열 형태로 제공할 수 있어 다양한 관점에서 동일한 입력값을 검증할 수 있는 유연성을 제공합니다. 이러한 특성은 회원가입 폼에서 비밀번호와 비밀번호 확인 값의 일치 여부를 확인하는 것과 같은 실용적인 시나리오에서 특히 유용합니다. custom 필드를 사용하면 checkFn: (value, store) => value !== store.password와 같은 간단한 표현식으로 두 필드 간의 관계를 검증하고 적절한 오류 메시지를 사용자에게 제공할 수 있습니다.",
      "8": "custom 필드의 진정한 강점은 동적이고 복잡한 검증 로직을 구현할 수 있다는 점입니다. 예를 들어, 사용자 닉네임에 부적절한 단어가 포함되지 않도록 검증하려 할 때, 이러한 금지어 목록이 백엔드 데이터베이스에서 관리되는 경우가 있습니다. 이런 상황에서도 서버로부터 데이터를 가져와 검증 로직에 적용함으로써 효과적인 유효성 검사가 가능합니다. 이 방식의 큰 이점은 데이터베이스의 금지어 목록이 업데이트되면, 프론트엔드 코드를 수정하지 않고도 자동으로 최신 정책이 적용된다는 점입니다. 이처럼 custom 필드는 외부 데이터 소스와의 통합을 통해 유연하고 확장 가능한 검증 시스템을 구축할 수 있게 해줍니다.",
      "9": "sicilian은 타입 안전하게 validate를 작성할 수 있도록 validateOptions 함수를 제공합니다. validateOptions 함수는 언뜻 보기에 단순히 입력받은 옵션을 그대로 반환하는 것처럼 보이지만, 실제로는 TypeScript 환경에서 중요한 역할을 합니다. 이 함수는 복잡한 폼 검증 규칙을 정의할 때 타입 추론과 자동 완성 기능의 혜택을 받을 수 있게 해줍니다.<br></br><br></br>특히 커스텀 검증 로직에서 store 객체의 타입이 정확하게 추론되어, 잘못된 속성 접근이나 타입 불일치와 같은 오류를 개발 단계에서 미리 발견할 수 있습니다. 이는 런타임에 발생할 수 있는 많은 오류를 컴파일 시점에 방지하고, 코드 작성 시 개발자 경험을 향상시킵니다. 또한 코드 리팩토링 시에도 타입 안전성을 보장하여, 폼 필드의 이름이나 타입이 변경될 때 연관된 검증 로직에서 필요한 변경 사항을 IDE가 자동으로 식별할 수 있게 합니다.",
      "10": "sicilian에는 validate를 제공할 수 있는 두 가지 방법이 있습니다. 첫 번째는 CreateForm 클래스나 useForm 훅의 validator 옵션을 통한 방법이고, 두 번째는 register 함수에 validate 객체를 직접 전달하는 방법입니다. 두 방법 모두 동일한 형식의 validate 객체를 사용하지만, 검증 우선순위에서는 차이가 있습니다. register 함수에 전달된 validate 객체는 폼 컨트롤러에 정의된 validator 객체보다 우선시되어, 동일한 필드에 대한 검증 규칙을 덮어씁니다. 이러한 구조는 특정 컴포넌트에서 폼의 일반적인 검증 로직을 재정의해야 할 때 유용하며, 코드의 유연성과 재사용성을 높여줍니다.",
      "11": "또한 검증 순서도 중요한데, validate 객체 내의 필드들은 선언된 순서대로 검증이 진행되며 첫 번째 실패한 규칙에서 검증이 중단됩니다. 아래의 첫 번째 예시 코드에서는 minLength 필드가 required 필드보다 먼저 검증되며, (minLength가 충족되면 required는 자연히 충족되므로) required는 사실상 아무 일도 하지 않습니다. 반면에 두 번째 예시에서는 required가 값의 유무를 먼저 검증하고, 이후 minLength가 값의 길이를 검증합니다. 따라서 어떤 input의 검증 결과가 예상과 다르다면 각 필드의 순서를 확인해보는 것이 좋습니다.",
      "list": {
        "0": "<cd>validate 객체</cd>: 하나의 특정 입력 필드에 대한 검증 규칙을 정의하는 객체로, required, minLength, RegExp 등의 개별 검증 규칙들을 포함합니다.",
        "1": "<cd>validator 객체</cd>: 폼 내 모든 필드에 대한 validate 객체들을 모아놓은 상위 레벨 객체로, 각 필드명을 키로 사용하여 해당 필드의 validate 객체를 값으로 가집니다."
      }
    },
    "provider": {
      "title": "SicilianProvider 컴포넌트와 useSicilianContext 훅",
      "0": "기존에는 input 태그에 스프레드 연산자를 사용하여 register 함수가 반환하는 객체의 프로퍼티를 그대로 전달했다. 이 방식은 매우 편리하지만, 한 가지 단점이 있다. 특정 input에 입력이 발생할 때 폼 전체가 리렌더링되는 문제가 생기는 것이다.",
      "1": "이를 방지하기 위해서는 스프레드 연산자를 사용하는 대신, register와 name을 개별 props로 전달하고 Input 컴포넌트 내부에서 이를 조합해 사용하는 방식으로 바꿔야 한다. 다만 이 접근 방식에는 또 다른 불편함이 있다. register와 name의 타입이 지나치게 좁게 추론되기 때문에, 이들을 컴포넌트의 props로 넘겨주는 과정이 상당히 번거롭다는 점이다.<br></br><br></br>이러한 문제를 해결하기 위해 Sicilian은 SicilianProvider 컴포넌트와 useSicilianContext 훅을 제공합니다. 앞서 간단히 언급했듯이, 이들은 내부적으로 React Context API를 기반으로 구현되어 있습니다. Context는 미리 정의된 값과 함수만 전달할 수 있기 때문에, 복잡한 타입 정의 문제에서도 비교적 자유롭게 사용할 수 있습니다.<br></br><br></br>SicilianProvider 컴포넌트는 register, name, validate, type, getValues, getErrors — 총 여섯 개의 값과 메서드를 포함하는 value 객체를 인자로 받습니다. 이 중 register와 name은 반드시 제공해야 하며, 특히 register의 타입에 따라 name에 허용되는 문자열의 타입이 자동으로 추론됩니다.",
      "2": "register와 name를 제외한 나머지는 옵셔널하게 제공할 수 있습니다. 그리고 이렇게 넣어준 값들은 하위 노드 어딘가에서 <cd>useSicilianContext</cd> 훅을 통해 조회할 수 있습니다. 만약 상위 노드에 SicilianProvider 컴포넌트가 존재하지 않으면 useSicilianContext 훅은 아래와 같은 에러를 던지게 됩니다.",
      "3": "만약 옵셔널하게 제공하는 validate, type, getValues, getErrors props를 SicilianProvider에 제공하지 않은 채 useSicilianContext 훅을 통해 조회하려 한다면 어떻게 될까요? validate와 type의 경우 타입 자체가 undefined를 포함하고 있어 상관이 없지만, 문제는 getValues와 getErrors 함수입니다.<br></br><br></br>이 두 함수를 SicilianProvider 컴포넌트에 제공하지 않은 채 useSicilianContext 훅을 통해 조회한다면, 실제로 조회되는 것은 getValues와 getErrors 함수가 아니라 <b>콘솔에 에러 메세지를 남기는 함수가 조회</b>됩니다. 이 에러 메세지를 통해 현재 어떤 컴포넌트에서 props로 넘겨주지 않고 getValues와 getErrors 함수를 사용하고 있는지를 확인할 수 있게 됩니다.",
      "4": "아래는 SicilianProvider와 useSicilianContext를 사용하는 Input 컴포넌트에 대한 간단한 예시입니다."
    },
    "appRouter": {
      "0": "Next.js App Router 환경에서 Sicilian은 반드시 ‘use client’를 붙여서 사용해야 합니다. 이는 Sicilian을 구성하는 ─ useSyncExternalStore, useContext 등의 ─ 요소는 모두 ‘use client’를 필요로 하기 때문입니다. 그 외의 문법은 기존과 동일하게 사용할 수 있습니다."
    }
  }
}

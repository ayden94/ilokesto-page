{
  "introduce": {
    "title": "utilinent를 소개합니다",
    "description": "React 애플리케이션의 규모가 커지고 로직이 복잡해짐에 따라, JSX 내부에 삼항 연산자가 여러 겹으로 중첩되거나 map 함수의 내부가 비대해지면서 코드의 가독성이 급격히 떨어지는 문제를 흔히 겪게 됩니다. utilinent는 바로 이러한 반복적인 UI 패턴과 로직을 보다 선언적이고 직관적인 컴포넌트로 해결하기 위해 탄생했습니다.<br></br><br></br>SolidJS의 간결하고 명료한 개발 방식에서 깊은 영감을 받은 utilinent는, 조건부 렌더링, 리스트 렌더링, 지연 로딩(lazy loading)과 같이 자주 사용되는 기능들을 명확한 API를 가진 컴포넌트로 캡슐화합니다. 예를 들어, 복잡한 조건 분기를 삼항 연산자 대신 '<'Show'>' 같은 컴포넌트로 대체하여 코드의 의도를 명확하게 드러낼 수 있습니다. 또한, '<'For'>' 컴포넌트를 사용하면 배열 데이터를 렌더링하는 코드를 간결하게 작성할 수 있을 뿐만 아니라, 데이터가 비어있을 경우를 위한 대체 UI까지 손쉽게 처리할 수 있습니다.<br></br><br></br>이처럼 utilinent를 활용하면 지저분한 로직을 뷰에서 분리하고, 재사용 가능한 컴포넌트로 만들어 코드의 가독성과 유지보수성을 극대화할 수 있습니다. 이는 단순히 코드를 깔끔하게 만드는 것을 넘어, 개발자가 비즈니스 로직에 더욱 집중할 수 있는 환경을 제공하며, 팀 전체의 생산성을 향상시키는 효과를 가져옵니다.",
    "installation": "설치 방법",
    "installationBody": "utilinent은 아래의 다양한 방법으로 설치할 수 있습니다.",
    "quickStart": "빠른 시작",
    "0": "React 애플리케이션에서 비동기 데이터를 다룰 때, 로딩 상태와 데이터의 존재 여부에 따라 UI를 다르게 표시하는 것은 흔한 패턴입니다. 다음은 이러한 상황을 처리하는 일반적인 React 코드 예시입니다.",
    "1": "utilinent가 제공하는 강력한 <cd>Show</cd>와 <cd>For</cd> 컴포넌트를 사용하면, 위 코드를 더 선언적이고 간결하게 개선할 수 있습니다. 로딩 및 데이터 유무에 따른 조건부 렌더링과 목록 렌더링을 직관적으로 처리하는 방법을 확인해 보세요."
  },
  "show": {
    "0": "<cd>Show</cd>는 복잡한 조건부 렌더링을 선언적이고 직관적으로 표현하게 해 주는 컴포넌트입니다. React에서 흔히 사용하는 삼항 연산자(<cd>? :</cd>)나 논리 연산자(<cd>&&</cd>)로 인해 JSX가 가독성을 잃고 의도가 묻히는 경우가 많은데, <cd>Show</cd>는 그런 분기 로직을 명확한 API로 대체합니다. <cd>when</cd>이 참일 때만 children을 렌더링하고, <cd>fallback</cd>을 이용해 조건이 거짓일 때의 대체 UI를 분명히 지정할 수 있어 코드 의도가 더 선명해집니다.",
    "subtitle1": "기본 사용법",
    "1": "가장 간단한 사용 예에서는 <cd>when</cd>에 조건을 넘기고, 필요하면 <cd>fallback</cd>으로 대체 UI를 제공합니다. children을 함수 형태로 전달하면 렌더링 시점의 값을 안전하게 받아 처리할 수 있어 타입 안정성과 표현력이 향상됩니다.",
    "subtitle2": "여러 조건을 동시에 검사",
    "2": "<cd>when</cd>에 배열을 전달하면 배열의 모든 요소가 truthy일 때만 children이 렌더링됩니다.",
    "subtitle3": "DOM 구조 유지 및 레이아웃 안정성",
    "3": "<cd>Show.div</cd>, <cd>Show.span</cd> 같은 태그 기반 변형을 사용하면, 외부 DOM 노드는 항상 존재시키면서 내부 콘텐츠만 조건에 따라 교체할 수 있습니다. 이렇게 하면 레이아웃이나 CSS가 불필요하게 깨지는 것을 방지하고, 시맨틱한 마크업을 유지하면서 조건부 렌더링을 안전하게 적용할 수 있습니다."
  },
  "observer": {
    "0": "<cd>Observer</cd>는 뷰포트 기반 렌더링을 통해 초기 로드 비용과 불필요한 렌더링을 줄이는 성능 최적화용 컴포넌트입니다. 내부적으로는 조건부 렌더링을 담당하는 <cd>Show</cd> 컴포넌트와, 요소의 가시성 변화를 감지하는 <cd>useIntersectionObserver</cd> 훅을 조합해 구현되어 있습니다. 이 조합은 이미지 지연 로딩, 무한 스크롤, 스크롤 기반 애니메이션 트리거 등 실제 사용자가 보는 시점에만 무거운 작업을 수행하도록 설계되어 초기 렌더링을 가볍게 만듭니다.",
    "subtitle1": "기본 사용법",
    "1": "가장 간단한 형태에서는 <cd>Observer</cd>에 <cd>fallback</cd>을 제공하고, 대상 요소가 뷰포트에 진입하면 실제 children이 렌더링됩니다. 예: 이미지를 지연 로드하거나, 아래로 스크롤했을 때만 무거운 컴포넌트를 마운트하는 경우에 유용합니다.",
    "subtitle2": "고급 사용법",
    "2": "<cd>onIntersect</cd> 콜백을 활용하면 특정 지점에 도달했을 때 데이터 프리페칭, 분석 이벤트 전송, 또는 UI 전환을 자동으로 수행할 수 있습니다. 예를 들어 사용자가 섹션에 도달하면 해당 섹션 관련 API를 미리 호출해 지연 시간을 줄이거나, 무한 스크롤에서 다음 페이지를 미리 로드하는 패턴에 활용할 수 있습니다.",
    "3": "내부에서 사용하는 <cd>useIntersectionObserver</cd> 훅은 복잡한 Intersection Observer API를 간단한 React 훅으로 추상화합니다. Intersection Observer는 요소의 가시성을 효율적으로 감지할 수 있는 브라우저 API이지만, 직접 사용하면 설정과 정리 로직이 복잡합니다. 이 훅은 Intersection Observer를 React의 라이프사이클에 맞게 추상화하여, ref와 상태만으로 간단하게 요소의 뷰포트 진입 여부를 추적할 수 있게 해줍니다. 스크롤 애니메이션, 지연 로딩, 무한 스크롤 등 다양한 시나리오에서 활용할 수 있습니다."
  },
  "optional": {
    "0": "<cd>OptionalWrapper</cd>는 조건부 래핑(conditional wrapping) 패턴을 간결하게 처리하는 유틸리티 컴포넌트입니다. 내부적으로는 렌더 여부를 결정하는 <cd>Show</cd> 컴포넌트를 사용해 조건부로 래핑을 적용하므로, 복잡한 삼항 연산자나 중복된 래퍼 코드를 피할 수 있습니다. 예를 들어 링크가 필요할 때는 <cd>a</cd> 태그로 감싸고, 필요하지 않을 때는 단순히 컨텐츠만 렌더링하도록 선언적으로 표현할 수 있습니다.",
    "subtitle1": "기본 사용법",
    "1": "가장 기본적인 형태에서는 조건(true/false)에 따라 지정한 래퍼로 컨텐츠를 감싸거나, 조건이 거짓일 경우 래퍼 없이 컨텐츠만 렌더링합니다. 이 패턴은 버튼 또는 링크를 조건부로 적용할 때 유용합니다."
  },
  "slacker": {
    "0": "<cd>Slacker</cd>는 대용량 웹 애플리케이션에서 초기 로드 비용을 줄이고 사용자 경험을 개선하기 위해 설계된 데이터 지연 로딩 컴포넌트입니다. 내부적으로는 뷰포트 감지를 담당하는 <cd>Observer</cd>와 결합되어, 해당 컴포넌트가 실제로 뷰포트에 진입했을 때만 비동기 <cd>loader</cd>를 실행합니다. 이 접근 방식은 API 호출, 동적 import, 무거운 데이터 페칭 등 비용이 큰 작업을 필요 시점에만 수행하게 하여 초기 렌더 시간을 크게 단축합니다.",
    "subtitle1": "기본 사용법",
    "1": "간단한 사용 예에서는 <cd>loader</cd>를 전달하고, 요소가 뷰포트에 진입하면 로더가 실행되어 반환된 데이터를 children에 전달합니다. 예: 큰 이미지 컬렉션, 위젯 데이터, 또는 페이지 섹션별 API 결과를 지연 로드할 때 유용합니다.",
    "subtitle2": "에러 처리 및 재시도",
    "2": "<cd>errorFallback</cd>에 함수를 전달하면 에러 정보와 재시도 함수를 받아 커스텀 UI를 렌더링할 수 있습니다. <cd>maxRetries</cd>와 지연 간격(backoff)을 설정해 자동 재시도를 구성할 수 있으며, 네트워크 오류나 일시적 실패를 우아하게 처리할 수 있습니다."
  },
  "for": {
    "0": "<cd>For</cd>는 리스트 렌더링과 빈 상태 처리를 하나로 통합한 선언적 컴포넌트입니다. React에서 리스트를 렌더링할 때 일반적으로 <cd>Array.map()</cd>을 사용하지만, 빈 배열이거나 데이터가 없을 때의 처리를 위해 추가적인 조건 분기가 필요했습니다. <cd>For</cd> 컴포넌트는 이러한 패턴을 하나로 통합하여, 배열 순회와 빈 상태 처리를 동시에 선언적으로 표현할 수 있게 해줍니다.",
    "subtitle1": "기본 사용법",
    "1": "배열이 비어있을 때의 처리를 별도 조건문 없이 선언적으로 표현할 수 있습니다. <cd>fallback</cd>은 빈 배열뿐만 아니라 <cd>null</cd>이나 <cd>undefined</cd>일 때도 표시됩니다.",
    "subtitle2": "DOM 구조 유지 및 레이아웃 안정성",
    "2": "<cd>For.ui</cd>, <cd>For.div</cd> 같은 태그 기반 변형을 사용하면, 외부 DOM 노드는 항상 존재시키면서 내부 콘텐츠만 조건에 따라 교체할 수 있습니다. 이렇게 하면 레이아웃이나 CSS가 불필요하게 깨지는 것을 방지하고, 시맨틱한 마크업을 유지하면서 조건부 렌더링을 안전하게 적용할 수 있습니다."
  },
  "repeat": {
    "0": "<cd>Repeat</cd>은 동일한 UI 블록을 반복적으로 렌더링할 때 사용하는 간결한 유틸리티입니다. 내부적으로는 리스트 렌더링 전용인 <cd>For</cd> 컴포넌트를 활용해 구현되어 있어, 인덱스 제공, 빈 상태 처리, 그리고 태그 기반 변형까지 자연스럽게 지원합니다. 스켈레톤 로더, 별점 표시, 그리드 레이아웃 등 반복 패턴을 더 직관적이고 선언적으로 표현할 수 있습니다.",
    "subtitle1": "기본 사용법",
    "1": "반복 횟수(count)만 지정하면 되고, 렌더 콜백에서 현재 인덱스를 받아 각 항목에 고유한 값을 부여하거나 콘텐츠를 생성할 수 있습니다. 코드가 간결해지고 의도가 명확해집니다.",
    "subtitle2": "DOM 구조 유지 및 레이아웃 안정성",
    "2": "<cd>Repeat</cd>는 태그 기반 변형(예: <cd>Repeat.div</cd>)을 제공하여 외부 컨테이너를 항상 유지하면서 내부 콘텐츠만 반복할 수 있습니다. 이로 인해 CSS 레이아웃이 깨지는 것을 방지하고, 스켈레톤 또는 그리드 레이아웃에서 일관된 마크업을 유지할 수 있습니다."
  },
  "slot": {
    "0": "<cd>Slot</cd>은 컴포넌트 합성의 유연성을 극대화하는 고급 패턴 구현입니다. 재사용 가능한 컴포넌트를 만들 때, 내부 구조를 유지하면서도 사용자가 원하는 요소로 렌더링하고 싶을 때가 있습니다. 예를 들어 Button 컴포넌트가 때로는 실제 <cd>'<'button'>'</cd> 태그로, 때로는 <cd>'<'a'>'</cd> 태그로 렌더링되어야 하는 경우입니다. <cd>Slot</cd>은 부모 컴포넌트의 props를 자식 요소에 지능적으로 병합하여, 이러한 유연성을 제공하면서도 스타일, 이벤트 핸들러, ref 등을 모두 보존합니다.",
    "subtitle1": "기본 사용법",
    "1": "<cd>asChild</cd> 패턴을 사용하여 컴포넌트의 렌더링 요소를 외부에서 제어할 수 있습니다. Button의 스타일과 동작을 유지하면서 다른 요소로 렌더링할 수 있습니다.",
    "subtitle2": "Slottable",
    "2": "복잡한 구조에서 특정 자식에게만 props를 전달하고 싶을 때 <cd>Slottable</cd>로 감싸면 됩니다. 아이콘과 텍스트를 조합한 버튼 등에 유용합니다."
  }
}

{
  "introduce": {
    "title": "utilinent를 소개합니다",
    "description": "React 애플리케이션의 규모가 커지고 로직이 복잡해짐에 따라, JSX 내부에 삼항 연산자가 여러 겹으로 중첩되거나 map 함수의 내부가 비대해지면서 코드의 가독성이 급격히 떨어지는 문제를 흔히 겪게 됩니다. utilinent는 바로 이러한 반복적인 UI 패턴과 로직을 보다 선언적이고 직관적인 컴포넌트로 해결하기 위해 탄생했습니다.<br></br><br></br>SolidJS의 간결하고 명료한 개발 방식에서 깊은 영감을 받은 utilinent는, 조건부 렌더링, 리스트 렌더링, 지연 로딩(lazy loading)과 같이 자주 사용되는 기능들을 명확한 API를 가진 컴포넌트로 캡슐화합니다. 예를 들어, 복잡한 조건 분기를 삼항 연산자 대신 '<'Show'>' 같은 컴포넌트로 대체하여 코드의 의도를 명확하게 드러낼 수 있습니다. 또한, '<'For'>' 컴포넌트를 사용하면 배열 데이터를 렌더링하는 코드를 간결하게 작성할 수 있을 뿐만 아니라, 데이터가 비어있을 경우를 위한 대체 UI까지 손쉽게 처리할 수 있습니다.<br></br><br></br>이처럼 utilinent를 활용하면 지저분한 로직을 뷰에서 분리하고, 재사용 가능한 컴포넌트로 만들어 코드의 가독성과 유지보수성을 극대화할 수 있습니다. 이는 단순히 코드를 깔끔하게 만드는 것을 넘어, 개발자가 비즈니스 로직에 더욱 집중할 수 있는 환경을 제공하며, 팀 전체의 생산성을 향상시키는 효과를 가져옵니다.",
    "installation": "설치 방법",
    "installationBody": "utilinent은 아래의 다양한 방법으로 설치할 수 있습니다.",
    "quickStart": "빠른 시작",
    "0": "React 애플리케이션에서 비동기 데이터를 다룰 때, 로딩 상태와 데이터의 존재 여부에 따라 UI를 다르게 표시하는 것은 흔한 패턴입니다. 다음은 이러한 상황을 처리하는 일반적인 React 코드 예시입니다.",
    "1": "utilinent가 제공하는 강력한 <cd>Show</cd>와 <cd>For</cd> 컴포넌트를 사용하면, 위 코드를 더 선언적이고 간결하게 개선할 수 있습니다. 로딩 및 데이터 유무에 따른 조건부 렌더링과 목록 렌더링을 직관적으로 처리하는 방법을 확인해 보세요."
  },
  "show": {
    "0": "<cd>Show</cd>는 조건부 렌더링을 선언적으로 표현하는 컴포넌트입니다. <cd>when</cd>이 truthy면 children을 렌더링하고, 그렇지 않으면 <cd>fallback</cd> (또는 아무것도) 렌더링합니다. 분기 로직을 JSX 밖으로 빼내 의도를 더 명확하게 만듭니다.",
    "subtitle1": "기본 사용법",
    "1": "<cd>when</cd>에 조건을 넘기고 필요하면 <cd>fallback</cd>을 제공합니다. children을 함수로 전달하면 렌더 시점의 값을 받을 수 있습니다.",
    "subtitle2": "여러 조건을 동시에 검사",
    "2": "<cd>when</cd>에 배열을 전달하면 모든 값이 truthy일 때만 children이 렌더링됩니다. 함수 children은 배열 값을 받습니다.",
    "subtitle3": "DOM 구조 유지 및 레이아웃 안정성",
    "3": "<cd>Show.div</cd> 또는 <cd>Show.span</cd>을 사용하면 외부 DOM을 유지하면서 내부 콘텐츠만 교체할 수 있습니다."
  },
  "switch": {
    "0": "<cd>Switch</cd>는 <cd>Match</cd>를 순서대로 평가해 가장 먼저 매칭되는 항목을 렌더링합니다. 매칭 규칙은 <cd>Show</cd>와 동일하며, 아무 것도 매칭되지 않으면 <cd>fallback</cd>이 렌더링됩니다.",
    "subtitle1": "기본 사용법",
    "1": "<cd>Switch</cd> 내부에 여러 <cd>Match</cd>를 배치하고 필요하면 <cd>fallback</cd>을 제공하세요.",
    "subtitle2": "함수형 children",
    "2": "<cd>Match</cd>에 함수를 전달하면 해당 분기의 값을 인자로 받을 수 있습니다.",
    "subtitle3": "DOM 구조 유지 및 레이아웃 안정성",
    "3": "<cd>Switch.div</cd>를 사용하면 래퍼 요소를 유지한 채 매칭된 콘텐츠만 교체할 수 있습니다."
  },
  "mount": {
    "0": "<cd>Mount</cd>는 children을 함수로 받거나 Promise를 반환할 수 있게 해, 비동기 결과가 준비되면 렌더링합니다. Promise가 해결되는 동안 <cd>fallback</cd>을 보여주고 오류는 <cd>onError</cd>로 전달합니다.",
    "subtitle1": "기본 사용법",
    "1": "children 함수에서 React 노드 또는 Promise를 반환해 렌더링 시점을 지연할 수 있습니다.",
    "subtitle2": "에러 처리",
    "2": "<cd>onError</cd>로 예외나 Promise 거부를 처리하고 안전한 <cd>fallback</cd> UI를 제공합니다.",
    "subtitle3": "DOM 구조 유지 및 레이아웃 안정성",
    "3": "<cd>Mount.div</cd> 같은 태그 변형을 사용하면 래퍼 요소를 유지하면서 내용만 교체할 수 있습니다."
  },
  "observer": {
    "0": "<cd>Observer</cd>는 요소가 뷰포트에 들어왔을 때만 children을 렌더링합니다. 보이지 않을 때는 <cd>fallback</cd>을 보여주고 교차 시점에 콜백을 받을 수 있습니다.",
    "subtitle1": "기본 사용법",
    "1": "<cd>fallback</cd>으로 플레이스홀더를 제공하고, 보이는 순간에만 무거운 콘텐츠를 마운트하세요.",
    "subtitle2": "한 번만 트리거 & 콜백",
    "2": "<cd>triggerOnce</cd>로 첫 교차 이후 관찰을 멈추고, <cd>onIntersect</cd>로 사이드 이펙트를 실행할 수 있습니다.",
    "subtitle3": "useIntersectionObserver 훅",
    "3": "훅은 <cd>ref</cd>, <cd>isIntersecting</cd>, <cd>entry</cd>를 제공해 커스텀 동작을 만들 수 있습니다."
  },
  "optional": {
    "0": "<cd>OptionalWrapper</cd>는 마크업을 복제하지 않고 조건부로 래핑하는 패턴을 제공합니다. 내부적으로 <cd>Show</cd>를 사용하므로 <cd>when</cd>이 truthy면 래퍼가 적용되고, falsy면 <cd>fallback</cd> 또는 원본 children이 렌더링됩니다.",
    "subtitle1": "기본 사용법",
    "1": "<cd>when</cd>과 <cd>wrapper</cd> 함수를 제공하면 children을 조건부로 감쌀 수 있습니다.",
    "subtitle2": "대체 래퍼",
    "2": "<cd>fallback</cd>을 이용해 조건이 거짓일 때 다른 래퍼를 적용할 수 있습니다."
  },
  "slacker": {
    "0": "<cd>Slacker</cd>는 뷰포트에 들어올 때 데이터를 로딩합니다. <cd>Observer</cd>와 <cd>loader</cd>를 결합해 로딩/에러/재시도 상태를 처리합니다.",
    "subtitle1": "기본 사용법",
    "1": "<cd>loader</cd>를 제공하고, 로딩된 데이터를 children에서 렌더링합니다.",
    "subtitle2": "에러 처리 및 재시도",
    "2": "<cd>errorFallback</cd>, <cd>maxRetries</cd>, <cd>retryDelay</cd>로 실패를 우아하게 처리합니다."
  },
  "for": {
    "0": "<cd>For</cd>는 배열 렌더링과 빈 상태 처리를 하나로 합친 컴포넌트입니다. <cd>map</cd>과 추가 조건문을 하나의 선언적 블록으로 대체합니다.",
    "subtitle1": "기본 사용법",
    "1": "렌더 함수로 항목을 그리며, 배열이 비어있거나 null/undefined일 때 <cd>fallback</cd>을 표시할 수 있습니다.",
    "subtitle2": "DOM 구조 유지 및 레이아웃 안정성",
    "2": "<cd>For.ul</cd> 또는 <cd>For.div</cd>를 사용하면 컨테이너를 유지한 채 내부 리스트만 교체할 수 있습니다.",
    "subtitle3": "키 처리",
    "3": "렌더 함수가 반환하는 요소에는 안정적인 <cd>key</cd>를 지정하세요."
  },
  "repeat": {
    "0": "<cd>Repeat</cd>는 동일한 UI 블록을 지정한 횟수만큼 렌더링합니다. 스켈레톤, 별점, 플레이스홀더에 유용합니다.",
    "subtitle1": "기본 사용법",
    "1": "<cd>times</cd>에 양의 정수를 지정하고 인덱스를 받아 렌더링합니다. <cd>times</cd>가 유효하지 않으면 <cd>fallback</cd>이 렌더링됩니다.",
    "subtitle2": "DOM 구조 유지 및 레이아웃 안정성",
    "2": "<cd>Repeat.div</cd> 같은 태그 변형은 래퍼 요소를 유지한 채 내용을 반복합니다."
  },
  "slot": {
    "0": "<cd>Slot</cd>은 컴포넌트 합성의 유연성을 극대화하는 고급 패턴 구현입니다. 재사용 가능한 컴포넌트를 만들 때, 내부 구조를 유지하면서도 사용자가 원하는 요소로 렌더링하고 싶을 때가 있습니다. 예를 들어 Button 컴포넌트가 때로는 실제 <cd>'<'button'>'</cd> 태그로, 때로는 <cd>'<'a'>'</cd> 태그로 렌더링되어야 하는 경우입니다. <cd>Slot</cd>은 부모 컴포넌트의 props를 자식 요소에 지능적으로 병합하여, 이러한 유연성을 제공하면서도 스타일, 이벤트 핸들러, ref 등을 모두 보존합니다.",
    "subtitle1": "기본 사용법",
    "1": "<cd>asChild</cd> 패턴을 사용하여 컴포넌트의 렌더링 요소를 외부에서 제어할 수 있습니다. Button의 스타일과 동작을 유지하면서 다른 요소로 렌더링할 수 있습니다.",
    "subtitle2": "Slottable",
    "2": "복잡한 구조에서 특정 자식에게만 props를 전달하고 싶을 때 <cd>Slottable</cd>로 감싸면 됩니다. 아이콘과 텍스트를 조합한 버튼 등에 유용합니다."
  },
  "createProxy": {
    "0": "<cd>createProxy</cd>는 <cd>Show.div</cd>나 <cd>For.ul</cd>처럼 동일한 동작을 다양한 태그로 제공하는 컴포넌트 패밀리를 만들며, 라이브러리 외부에서도 활용할 수 있습니다. 아래 단계는 Custom Clickable 예제로 전체 흐름을 설명합니다.",
    "subtitle1": "props와 base 정의",
    "1": "공통 동작을 담은 base 컴포넌트를 먼저 정의합니다. 프록시는 이를 태그 변형마다 재사용합니다.",
    "1a": "왜 <cd>BaseClickableType&lt;X = object&gt;</cd>인가요? 프록시는 <cd>ClickableProps</cd>와 태그/컴포넌트 고유 props를 함께 받아야 합니다. <cd>X</cd>는 태그 props 자리이고 <cd>X &amp; ClickableProps</cd>로 병합됩니다. 기본값 <cd>object</cd>는 base를 추가 props 없이도 쓰기 쉽게 해줍니다. 제네릭이 없으면 <cd>Clickable.div</cd> 같은 변형에서 <cd>className</cd>, <cd>href</cd>, <cd>role</cd> 같은 네이티브 props 타입이 사라집니다.",
    "subtitle2": "renderForTag + ProxyType 추가",
    "2": "태그 렌더러와 프록시 타입을 정의해 <cd>Clickable.div</cd> 같은 변형을 타입으로 보장합니다.",
    "2a": "왜 <cd>BaseClickableFn extends BaseTypeHelperFn</cd>이고 <cd>this[\"props\"]</cd>를 쓰나요? <cd>ProxyType</cd>은 <cd>BaseTypeHelperFn</cd>을 타입 레벨 함수처럼 취급합니다. 각 태그의 props를 <cd>props</cd> 슬롯에 주입한 뒤 <cd>type</cd>을 평가해 최종 시그니처를 만듭니다. <cd>this[\"props\"]</cd>를 사용해야 태그별 props가 반영되어 <cd>Clickable.div</cd>는 <cd>ComponentPropsWithRef&lt;\"div\"&gt;</cd> + <cd>ClickableProps</cd>가 되고, <cd>Clickable.Link</cd>는 등록된 컴포넌트 props를 받습니다. 여기에 <cd>ClickableProps</cd>만 고정하면 태그 props가 전달되지 않습니다.",
    "subtitle3": "커스텀 컴포넌트 등록 (선택)",
    "3": "카테고리에 컴포넌트를 등록하고 <cd>UtilinentRegister</cd>를 확장해 <cd>Clickable.*</cd>를 타입 안전하게 사용합니다.",
    "subtitle4": "사용 예시",
    "4": "기본 컴포넌트와 태그/컴포넌트 변형을 사용할 수 있습니다."
  }
}

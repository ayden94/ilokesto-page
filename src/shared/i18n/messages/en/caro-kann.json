{
  "introduce": {
    "title": "Introduce the caro-kann",
    "description": "caro-kann is a global state management tool internally built with the useSyncExternalStore hook. It supports TypeScript and is compatible with both Next.js and React.js. With a syntax similar to useState, caro-kann is intuitive for developers familiar with React.js.",
    "whatsNew": "Whatâ€™s new in caro-kann@4.0.0",
    "newArray": [
      "The Zustand middleware has now been completely removed. Also, the usage of the validate middleware has changed.",
      "<cd>useStore.derived</cd> has been renamed to <cd>useStore.readOnly</cd>. Additionally, a <cd>writeOnly</cd> method has been added to <cd>useStore</cd>. This allows for clearer and more efficient state management, even in components that need to change state but do not need to subscribe to the state directly. These changes make the code's intent clearer and contribute to reducing unnecessary re-renders.",
      "The provider, which was removed in the previous version, has returned. This allows for the configuration of independent state trees within specific contexts, further enhancing the application's flexibility and reusability.",
      "All rules to follow when writing selector functions have been removed. Consequently, developers can define selector functions freely without unnecessary constraints, which contributes to increasing the code's flexibility and expressiveness. Internally, selector processing has been improved, enabling stable state management without performance degradation despite this freedom.",
      "<cd>setValue</cd> now always operates consistently, regardless of the presence or absence of a selector function. This change enhances the API's intuitiveness and significantly helps reduce the possibility of bugs caused by exceptional behavior. As a result, developers can update state in a more predictable and stable manner.",
      "An <cd>adaptor</cd> utility function has been added for use with <cd>setValue</cd> to easily change complex object states.",
      "A <cd>merge</cd> utility function has been added to combine multiple <cd>useStore</cd> instances. This allows developers to flexibly configure state using either a top-down approach with <cd>selector function + adaptor</cd> or a bottom-up approach with <cd>merge</cd>. Each approach can be selectively applied depending on the component structure or data flow, effectively addressing various architectural requirements. Overall, this update is an improvement that considers both consistency and scalability, significantly enhancing productivity and maintainability in actual development environments."
    ],
    "installation": "Installation",
    "installationBody": "Caro-Kann can be installed in various ways as below.",
    "createStore": "Create a store"
  },
  "tutorials": {
    "title": "Tutorial: Building a Shopping Cart",
    "description": "This tutorial guides you through the process of implementing a simple yet practical shopping cart feature using the Caro-Kann library in a React environment. You will learn how to efficiently manage state and easily integrate various additional features through Caro-Kann's intuitive state management approach and powerful middleware system.<br></br><br></br>This tutorial is aimed at developers with a basic understanding of React and aims to help you grasp the core concepts and practical usage of Caro-Kann so that you can apply it to real projects.",
    "createStore": {
      "title": "Create a store",
      "0": "Before starting application state management, it's a good idea to first define the structure of the data we'll be working with. Here, we create a TypeScript type to clearly specify the attributes of a 'Product' that will be placed in the shopping cart. Each product should have a required id, name, and price, and may optionally include imageUrl and description. Defining the type upfront helps reduce data-related errors during development and improves code readability and maintainability.",
      "1": "Next, we import the <cd>create</cd> function from the Caro-Kann library to create a global state store. The <cd>create</cd> function takes an initial state value as an argument and returns a custom hook that can manage that state. In this example, we set an empty array <cd>[]</cd> as the initial state, indicating that the shopping cart is initially empty. The <cd>useCart</cd> hook, returned by the <cd>create'<'Array'<'Product'>>'([])</cd> call, will now be the core interface used by all components in our application to access and modify the shopping cart state."
    },
    "useCart": {
      "title": "Changing Global State with useCart",
      "0": "Now let's look at how to change the shopping cart state in actual components using the <cd>useCart</cd> hook we created.<br></br><br></br>First, the <cd>ProductBinder</cd> component receives a list of products (<cd>productList</cd>) from the server as props and is responsible for rendering a <cd>ProductCard</cd> component for each product. It acts as a list renderer, serving as a container to display multiple product information on the screen.",
      "1": "Calling the <cd>useCart()</cd> hook inside this component returns a tuple containing the current cart state (<cd>cart</cd>) and a function to change the state (<cd>setCart</cd>), similar to React's <cd>useState</cd> hook.",
      "2": "In the <cd>onClick</cd> handler of the 'Add to Cart' button, the <cd>setCart</cd> function is used. It employs a functional update approach (<cd>setCart(prev => [...prev, product])</cd>), taking the previous state (<cd>prev</cd>) and returning a new array with the new product (<cd>product</cd>) added to the end. This is a good pattern for maintaining state immutability and helps React detect changes and update the UI efficiently.<br></br><br></br>However, looking at the current implementation of the <cd>ProductBinder</cd> component, it doesn't display the contents of the cart. That is, it doesn't need to read the <cd>cart</cd> state value directly; it only performs the function of adding items to the cart via the <cd>setCart</cd> function. In such cases, optimization can be considered to prevent the component from unnecessarily re-rendering whenever the cart state changes.<br></br><br></br>Caro-Kann provides the <cd>writeOnly</cd> method built into the <cd>useCart</cd> hook for such situations. Using <cd>useCart.writeOnly()</cd> retrieves only the state-modifying function (corresponding to <cd>setCart</cd>) without fetching the state value itself.",
      "3": "This allows the <cd>ProductBinder</cd> component to not subscribe to changes in the current state of the cart, enabling it to solely perform the role of adding products while avoiding unnecessary re-renders. This is a useful optimization technique that can contribute to performance improvements, especially when state changes frequently or many components share the same state."
    },
    "readOnly": {
      "title": "Managing Derived State with readOnly method",
      "0": "The application's Header component plays an important role in visually showing the user the total number of products currently in the shopping cart. To implement this feature, we utilize the <cd>readOnly</cd> method of the <cd>useCart</cd> hook.<br></br><br></br>The <cd>readOnly</cd> method is a powerful feature that allows access to the current value of the state store to extract or calculate desired data. This method takes a callback function as an argument, and this callback function receives the current state (<cd>store</cd>) as a parameter and returns a derived value.<br></br><br></br>In the example below, <cd>useCart.readOnly(store => store.length)</cd> is used to calculate the total number of products in the cart (<cd>cartLength</cd>) through the <cd>length</cd> property of the cart array (<cd>store</cd>).",
      "1": "The main advantages of using <cd>readOnly</cd> are as follows:",
      "2": "Consequently, <cd>useCart.readOnly</cd> is very useful for creating components that depend only on specific parts of the state or derived values, and it helps improve the reactivity and performance of the application.",
      "list": {
        "0": "<b>Selective Subscription</b>: The component re-renders only in response to changes in the specific value returned by the callback function, not the entire state object. For example, the <cd>Header</cd> component will only re-render when products are added or removed from the cart, changing <cd>store.length</cd>. If only an attribute of a specific item in the cart changes but the total count remains the same, this component will not re-render, reducing unnecessary operations.",
        "1": "<b>Derived State Calculation</b>: It's not just about fetching a part of the state; you can create calculated values (derived state) based on the state. For example, logic to calculate the total cart amount or to filter and show the count of items meeting specific criteria can be handled within the <cd>readOnly</cd> callback.",
        "2": "<b>Performance Optimization</b>: By subscribing precisely to only the necessary data, it prevents unnecessary re-renders that occur when other parts of the state change. This significantly contributes to performance optimization, especially in applications with complex state structures or frequent state updates."
      }
    },
    "cartPage": {
      "title": "Creating the Cart Page",
      "0": "The cart page displays a list of products selected by the user and provides functionality to remove individual products or clear the entire cart. It also calculates and displays the total amount for all products in the cart. This page is primarily composed of a <cd>Cart</cd> component, and each cart item can be rendered via <cd>ProductCard</cd> (or a separate <cd>CartItemCard</cd>).<br></br><br></br>In the <cd>Cart</cd> component, a selector function is passed to the <cd>useCart</cd> hook to efficiently retrieve only the necessary data. This selector function takes the current cart state (<cd>store</cd>) as an argument and returns an object containing the list of cart items (<cd>items</cd>) and the total price of all items (<cd>priceTotal</cd>). This way, the <cd>Cart</cd> component only re-renders when the cart items or the total amount changes.",
      "list": {
        "0": "<cd>items</cd>: An array of product objects currently in the cart.",
        "1": "<cd>priceTotal</cd>: The sum of <cd>product.price</cd> for each item in the <cd>items</cd> array."
      }
    }
  }
}

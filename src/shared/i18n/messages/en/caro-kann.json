{
  "introduce": {
    "title": "Introduce the caro-kann",
    "description": "caro-kann is a global state management tool internally built with the useSyncExternalStore hook. It supports TypeScript and is compatible with both Next.js and React.js. With a syntax similar to useState, caro-kann is intuitive for developers familiar with React.js.",
    "whatsNew": "What’s new in caro-kann@4.0.0",
    "newArray": [
      "The Zustand middleware has now been completely removed. Also, the usage of the validate middleware has changed.",
      "<cd>useStore.derived</cd> has been renamed to <cd>useStore.readOnly</cd>. Additionally, a <cd>writeOnly</cd> method has been added to <cd>useStore</cd>. This allows for clearer and more efficient state management, even in components that need to change state but do not need to subscribe to the state directly. These changes make the code's intent clearer and contribute to reducing unnecessary re-renders.",
      "The provider, which was removed in the previous version, has returned. This allows for the configuration of independent state trees within specific contexts, further enhancing the application's flexibility and reusability.",
      "All rules to follow when writing selector functions have been removed. Consequently, developers can define selector functions freely without unnecessary constraints, which contributes to increasing the code's flexibility and expressiveness. Internally, selector processing has been improved, enabling stable state management without performance degradation despite this freedom.",
      "<cd>setValue</cd> now always operates consistently, regardless of the presence or absence of a selector function. This change enhances the API's intuitiveness and significantly helps reduce the possibility of bugs caused by exceptional behavior. As a result, developers can update state in a more predictable and stable manner.",
      "An <cd>adaptor</cd> utility function has been added for use with <cd>setValue</cd> to easily change complex object states.",
      "A <cd>merge</cd> utility function has been added to combine multiple <cd>useStore</cd> instances. This allows developers to flexibly configure state using either a top-down approach with <cd>selector function + adaptor</cd> or a bottom-up approach with <cd>merge</cd>. Each approach can be selectively applied depending on the component structure or data flow, effectively addressing various architectural requirements. Overall, this update is an improvement that considers both consistency and scalability, significantly enhancing productivity and maintainability in actual development environments."
    ],
    "installation": "Installation",
    "installationBody": "caro-kann can be installed in various ways as below.",
    "createStore": "Create a store"
  },
  "tutorials": {
    "title": "Tutorial: Building a Shopping Cart",
    "description": "This tutorial guides you through the process of implementing a simple yet practical shopping cart feature using the caro-kann library in a React environment. You will learn how to efficiently manage state and easily integrate various additional features through caro-kann's intuitive state management approach and powerful middleware system.<br></br><br></br>This tutorial is aimed at developers with a basic understanding of React and aims to help you grasp the core concepts and practical usage of caro-kann so that you can apply it to real projects.",
    "createStore": {
      "title": "Create a store",
      "0": "Before starting application state management, it's a good idea to first define the structure of the data we'll be working with. Here, we create a TypeScript type to clearly specify the attributes of a 'Product' that will be placed in the shopping cart. Each product should have a required id, name, and price, and may optionally include imageUrl and description. Defining the type upfront helps reduce data-related errors during development and improves code readability and maintainability.",
      "1": "Next, we import the <cd>create</cd> function from the caro-kann library to create a global state store. The <cd>create</cd> function takes an initial state value as an argument and returns a custom hook that can manage that state. In this example, we set an empty array <cd>[]</cd> as the initial state, indicating that the shopping cart is initially empty. The <cd>useCart</cd> hook, returned by the <cd>create'<'Array'<'Product'>>'([])</cd> call, will now be the core interface used by all components in our application to access and modify the shopping cart state."
    },
    "useCart": {
      "title": "Changing Global State with useCart",
      "0": "Now let's look at how to change the shopping cart state in actual components using the <cd>useCart</cd> hook we created.<br></br><br></br>First, the <cd>ProductBinder</cd> component receives a list of products (<cd>productList</cd>) from the server as props and is responsible for rendering a <cd>ProductCard</cd> component for each product. It acts as a list renderer, serving as a container to display multiple product information on the screen.",
      "1": "Calling the <cd>useCart()</cd> hook inside this component returns a tuple containing the current cart state (<cd>cart</cd>) and a function to change the state (<cd>setCart</cd>), similar to React's <cd>useState</cd> hook.",
      "2": "In the <cd>onClick</cd> handler of the 'Add to Cart' button, the <cd>setCart</cd> function is used. It employs a functional update approach (<cd>setCart(prev => [...prev, product])</cd>), taking the previous state (<cd>prev</cd>) and returning a new array with the new product (<cd>product</cd>) added to the end. This is a good pattern for maintaining state immutability and helps React detect changes and update the UI efficiently.<br></br><br></br>However, looking at the current implementation of the <cd>ProductBinder</cd> component, it doesn't display the contents of the cart. That is, it doesn't need to read the <cd>cart</cd> state value directly; it only performs the function of adding items to the cart via the <cd>setCart</cd> function. In such cases, optimization can be considered to prevent the component from unnecessarily re-rendering whenever the cart state changes.<br></br><br></br>caro-kann provides the <cd>writeOnly</cd> method built into the <cd>useCart</cd> hook for such situations. Using <cd>useCart.writeOnly()</cd> retrieves only the state-modifying function (corresponding to <cd>setCart</cd>) without fetching the state value itself.",
      "3": "This allows the <cd>ProductBinder</cd> component to not subscribe to changes in the current state of the cart, enabling it to solely perform the role of adding products while avoiding unnecessary re-renders. This is a useful optimization technique that can contribute to performance improvements, especially when state changes frequently or many components share the same state."
    },
    "readOnly": {
      "title": "Managing Derived State with readOnly method",
      "0": "The application's Header component plays an important role in visually showing the user the total number of products currently in the shopping cart. To implement this feature, we utilize the <cd>readOnly</cd> method of the <cd>useCart</cd> hook.<br></br><br></br>The <cd>readOnly</cd> method is a powerful feature that allows access to the current value of the state store to extract or calculate desired data. This method takes a callback function as an argument, and this callback function receives the current state (<cd>store</cd>) as a parameter and returns a derived value.<br></br><br></br>In the example below, <cd>useCart.readOnly(store => store.length)</cd> is used to calculate the total number of products in the cart (<cd>cartLength</cd>) through the <cd>length</cd> property of the cart array (<cd>store</cd>).",
      "1": "The main advantages of using <cd>readOnly</cd> are as follows:",
      "2": "Consequently, <cd>useCart.readOnly</cd> is very useful for creating components that depend only on specific parts of the state or derived values, and it helps improve the reactivity and performance of the application.",
      "list": {
        "0": "<b>Selective Subscription</b>: The component re-renders only in response to changes in the specific value returned by the callback function, not the entire state object. For example, the <cd>Header</cd> component will only re-render when products are added or removed from the cart, changing <cd>store.length</cd>. If only an attribute of a specific item in the cart changes but the total count remains the same, this component will not re-render, reducing unnecessary operations.",
        "1": "<b>Derived State Calculation</b>: It's not just about fetching a part of the state; you can create calculated values (derived state) based on the state. For example, logic to calculate the total cart amount or to filter and show the count of items meeting specific criteria can be handled within the <cd>readOnly</cd> callback.",
        "2": "<b>Performance Optimization</b>: By subscribing precisely to only the necessary data, it prevents unnecessary re-renders that occur when other parts of the state change. This significantly contributes to performance optimization, especially in applications with complex state structures or frequent state updates."
      }
    },
    "cartPage": {
      "title": "Creating the Cart Page",
      "0": "The cart page displays a list of products selected by the user and provides functionality to remove individual products or clear the entire cart. It also calculates and displays the total amount for all products in the cart. This page is primarily composed of a <cd>Cart</cd> component, and each cart item can be rendered via <cd>ProductCard</cd> (or a separate <cd>CartItemCard</cd>).<br></br><br></br>In the <cd>Cart</cd> component, a selector function is passed to the <cd>useCart</cd> hook to efficiently retrieve only the necessary data. This selector function takes the current cart state (<cd>store</cd>) as an argument and returns an object containing the list of cart items (<cd>items</cd>) and the total price of all items (<cd>priceTotal</cd>). This way, the <cd>Cart</cd> component only re-renders when the cart items or the total amount changes.",
      "list": {
        "0": "<cd>items</cd>: An array of product objects currently in the cart.",
        "1": "<cd>priceTotal</cd>: The sum of <cd>product.price</cd> for each item in the <cd>items</cd> array."
      }
    },
    "middleware": {
      "title": "Extending Cart Functionality with Middleware Composition: Backup and Action Verification",
      "0": "One of caro-kann's powerful features is the ability to easily compose middleware to extend store functionality. Here, we'll apply <cd>persist</cd> and <cd>logger</cd> middleware to keep the cart state in the browser and easily track state changes.",
      "subtitle1": "1. Persisting cart state with persist middleware",
      "1": "By default, an web application's state is reset when the page is refreshed or the browser is closed. To prevent users from losing the products they've added to their cart, the state needs to be stored somewhere. The <cd>persist</cd> middleware makes managing this state persistence very simple.<br></br><br></br>The <cd>persist</cd> middleware automatically saves data to a specified storage (e.g., <cd>localStorage</cd>) whenever the state changes, and restores the state by loading this data when the application reloads. Here's how to apply the <cd>persist</cd> middleware to the <cd>useCart</cd> store:",
      "subtitle2": "2. Tracking state changes with logger middleware",
      "2": "During development, understanding how the state changes and what actions caused those changes is crucial for debugging. The <cd>logger</cd> middleware helps track this process easily by printing state change-related information to the console.<br></br><br></br>The <cd>logger</cd> middleware can be composed with the <cd>persist</cd> middleware. Middleware is applied by wrapping functions, so you can think of it as executing from the inside out. That is, when a state change occurs, <cd>logger</cd> acts first, then <cd>persist</cd> acts.",
      "3": "Now, whenever a product is added to or removed from the cart, relevant logs will be printed to the browser console, allowing clear verification of the state change process. You can also adjust logger options to selectively view only the necessary information."
    },
    "merge": {
      "title": "Merging stores with merge",
      "0": "As an application grows, it can be more efficient to manage related states in separate stores. For example, cart state can be managed in a <cd>useCart</cd> store, and user profile information in a <cd>useProfile</cd> store.<br></br><br></br>caro-kann provides a <cd>merge</cd> utility to conveniently use and manage these separated stores as a single, unified hook. <cd>merge</cd> takes multiple store hooks as input and returns a new hook that can access the state and setter functions of each store.<br></br><br></br>First, define the individual stores. Here, we'll use cart (<cd>useCart</cd>) and user profile (<cd>useProfile</cd>) stores as examples. A <cd>User</cd> type also needs to be defined.",
      "1": "Now, use the <cd>merge</cd> utility to combine the <cd>useCart</cd> and <cd>useProfile</cd> stores. Pass an object to the <cd>merge</cd> function, where each key will be the name used in the merged store, and the value will be the respective store hook.",
      "2": "Using the <cd>useProfileAndCart</cd> hook created this way, you can access the state and setter functions of each store as if dealing with one large store.<br></br><br></br>For example, within a component, you can use it as follows:"
    },
    "finishing": {
      "title": "Wrapping up: Efficient State Management with caro-kann",
      "0": "So far, we've explored how to implement basic shopping cart functionality using the caro-kann library. Through this tutorial, you've learned how to create a store with the <cd>create</cd> function, read and update state via the <cd>useCart</cd> hook, optimize with <cd>writeOnly</cd> and <cd>readOnly</cd> methods, and manage derived state using selectors. We also looked at how to easily extend store functionality by composing <cd>persist</cd> and <cd>logger</cd> middleware, and how to manage multiple stores integratively with the <cd>merge</cd> utility.<br></br><br></br>The topics covered here are just a part of the diverse features caro-kann offers. In actual application development, you'll encounter more complex state logic, asynchronous operations, advanced middleware usage, and various other scenarios. caro-kann provides powerful and flexible features to meet these advanced requirements, helping developers handle state management more efficiently and intuitively.<br></br><br></br>For deeper learning and to explore the full potential of caro-kann, we highly recommend referring to the official documentation. The official documentation provides detailed guidance on various APIs not covered in this tutorial, advanced usage patterns, and best practices for real-world production environments. We hope you have a more enjoyable and productive state management experience with caro-kann."
    }
  },
  "create-store": {
    "title": "Creating a Store",
    "0": "In caro-kann, a store is defined as an external space where global state is saved. To create such a store, you must use the <cd>create</cd> function provided by caro-kann. This function takes the initial value of the state as a parameter, stores it in an internal store, and returns a <cd>useStore</cd> hook.<br></br><br></br>The <cd>create</cd> function must be called outside of a component. If called inside a component, a new store will be created every time the component re-renders, causing the previous state to be lost. This behavior contradicts the purpose of global state management, so special care must be taken.",
    "1": "The <cd>useStore</cd> hook is the only way to access the store created through the <cd>create</cd> function, and it returns a tuple of <cd>[value, setValue]</cd>, just like React's <cd>useState</cd> hook."
  },
  "basic-usage": {
    "title": "Basic Usage of useStore",
    "0": "As we've seen before, <cd>useStore</cd> returns a tuple of <cd>[value, setValue]</cd>, just like React's <cd>useState</cd> hook. Therefore, any developer familiar with React can easily use <cd>useStore</cd>.",
    "subtitle1": "Selector Function",
    "1": "The code we looked at above has one problem. Although the component only needs the email, name, and phoneNumber states, <cd>useStore</cd> is subscribing to the entire store. Therefore, if the age value changes elsewhere, the <cd>ProfileCard</cd> component, which doesn't need the age value, will also re-render.<br></br><br></br>To solve this problem, the <cd>useStore</cd> hook can take a selector function as an argument. By using a selector function, components can subscribe only to the state they actually need, preventing unnecessary re-renders. This is particularly helpful for rendering optimization in applications where the state object is large and complex, or where performance is critical.",
    "subtitle2": "Derived State",
    "2": "Selector functions not only prevent unnecessary re-renders by subscribing only to the required state but can also transform or calculate existing state to create new derived state.<br></br><br></br>For example, you can separate complex logic, such as calculating the total price from a list of cart items or determining adulthood from user data, outside the component. This approach helps keep UI components concise and allows state logic to be managed in a reusable form.",
    "subtitle3": "readOnly and writeOnly Methods",
    "3": "useStore returns a tuple of <cd>[value, setValue]</cd>. But does it always have to? The <cd>ProfileCard</cd> component we've looked at so far only fetches and uses state; it doesn't need the functionality to change state. In this case, the setValue function is unused and can be an unnecessary resource.<br></br><br></br>To address this situation, useStore provides <cd>readOnly</cd> and <cd>writeOnly</cd> methods. The readOnly method is for components that only read state, returning only the state value and not providing an update function. Conversely, the writeOnly method can be used when you only want to change state and not subscribe to it. This allows you to use an optimized interface tailored to the actual needs of the component."
  },
  "provider": {
    "title": "Provider",
    "0": "There's one more special method hidden in <cd>useStore</cd>. The <cd>Provider</cd> method is a special feature provided by caro-kann that allows you to configure independent state trees while using the same store. This feature enables the creation and management of different instances of the same store within an application.<br></br><br></br>Provider acts like a React component and receives the store as props. <cd>useStore</cd> is a means to access the store created via <cd>create</cd>, not the store itself. Therefore, caro-kann provides a <cd>createStore</cd> function that returns the store directly, instead of <cd>useStore</cd>. This allows you to provide independent state to specific component trees.",
    "subtitle1": "Use Cases",
    "1": "Provider is particularly useful in the following situations:",
    "2": "Through Provider, you can significantly enhance the flexibility of state management and achieve both state isolation and reusability in complex applications.",
    "subtitle2": "Provider and Middleware",
    "3": "As we will explore in more detail later, caro-kann's middleware adds additional functionality to create and createStore. And Provider works without issues regardless of which middleware is used or in what order, as long as the store types are the same. It even works correctly if different middlewares are applied to create and createStore, as shown in the example below.",
    "4": "However, there is one exception. If the reducer middleware is used with the create function, the same reducer middleware must also be used with the createStore function, and vice versa. This is because the reducer middleware modifies the behavior of setValue, the core function for changing the store's state. Therefore, if the usage of reducer middleware is inconsistent between create and createStore, unexpected issues can arise in the state update logic.<br></br><br></br>Fortunately, when using TypeScript, caro-kann internally and automatically identifies the middleware applied to each store. If an inconsistency in reducer middleware usage is detected, it informs the developer with the following warning message:",
    "5": "\"Warning: Reducer usage must be consistent. Both should use reducers, or neither should.\"",
    "6": "This helps prevent potential errors that might occur during the development process.",
    "list": {
      "0": "<b>Testing environments</b>: Provides independent state for each test, enabling isolated testing.",
      "1": "<b>Multiple instance components</b>: When the same component is used multiple times but needs to have independent states.",
      "2": "<b>Theme management</b>: When different parts of the application need to use different theme settings.",
      "3": "<b>User-specific settings</b>: When independent state management is needed for each user in a multi-user interface."
    }
  },
  "adaptor": {
    "title": "the Adaptor Function",
    "0": "Often, an application's state takes the form of a complex object with multiple layers. For example, it might include user profile information, settings, and other nested objects within them. In such situations, if you try to change only a specific part of the state using the <cd>setValue</cd> function, writing code to update only the desired value while keeping the rest unchanged can be cumbersome. This is because you might need to use the spread operator (<cd>...</cd>) multiple times to maintain immutability or worry about deep copying.",
    "1": "To alleviate this inconvenience, caro-kann provides the adaptor utility function. The adaptor function is internally implemented using Immer library's produce function, allowing developers to write code as if they are directly modifying a 'draft' version of the state object. Internally, it maintains immutability while creating a new state object, so developers can intuitively update the state without complex spread operators."
  },
  "merge": {
    "title": "the Merge Function",
    "0": "The <cd>merge</cd> function is a useful utility that bundles multiple independent <cd>useStore</cd> hooks to act like a single, unified <cd>useStore</cd> hook. As applications grow in scale, it often becomes common to manage state by separating it into multiple smaller stores based on features or domains. For example, you might have a <cd>useCart</cd> store for managing cart state and a <cd>useUserProfile</cd> store for managing user profile information.<br></br><br></br>In such cases, a specific component might require both cart information and user profile information. Without the <cd>merge</cd> function, you would have to call <cd>useCart()</cd> and <cd>useUserProfile()</cd> separately within that component. This could lead to multiple state subscription logics within the component, making the code somewhat verbose.",
    "1": "The merge function was introduced to improve this situation. It bundles a maximum of eight useStore hooks into a single object, creating a useMergedStore hook similar to useStore. Using this new hook, you can fetch the state of multiple related stores with a single call and receive a unified setValue function to update those states. This is a 'bottom-up' approach, allowing you to combine individually well-defined small stores as needed to construct larger state logic. Consequently, component code becomes more concise, and the consistency of state access and management is enhanced.",
    "2": "useMergedStore can use selector functions or the readOnly and writeOnly methods provided by useStore in the same way. However, Provider is not provided. This is because the merge function itself focuses on combining multiple store instances (or store access hooks) that can already be created and managed independently.",
    "subtitle1": "Merging Stores with Different Middleware",
    "3": "One of the powerful features of the merge function is its ability to freely combine stores that use different middleware. Each store can independently use middleware suited to its requirements, while being managed through a unified interface via merge.<br></br><br></br>The following example implements sidebar toggle functionality, applying different data persistence strategies for desktop and mobile environments:",
    "4": "Using the merged store this way allows you to manage state consistently while maintaining each store's individual characteristics:",
    "5": "The main advantages of this approach are:",
    "6": "The merge function efficiently combines states with different requirements, enabling consistent and intuitive state management even in complex applications.",
    "subtitle2": "getStoreFrom",
    "7": "A merged store created by the merge function (e.g., useMergedStore), when rendered under a useSomeStore.Provider component, will by default fetch values for each constituent store from the nearest Provider context. For example, if useMergedStore includes useUserProfile and is inside a useUserProfile.Provider, the userProfile part of useMergedStore will get its value from the store instance provided by that Provider.<br></br><br></br>However, the merge function can accept a getStoreFrom option as its second optional argument. This option, in object form, allows you to explicitly specify where each useStore key used in the merge should fetch its value from. You can set a value of 'context' or 'root' for each key.",
    "8": "This <cd>getStoreFrom</cd> option gives developers fine-grained control over which scope of state each part of the merged store references, greatly enhancing flexibility in complex application architectures.",
    "subtitle3": "Limitations",
    "9": "While the merge function offers a powerful way to conveniently combine multiple useStore hooks, it has a few limitations.",
    "10": "Error: merge function can only merge up to 8 stores at a time. Please reduce the number of stores you are trying to merge.",
    "11": "There are two main reasons for this limitation:",
    "12": "Furthermore, because the merge function returns <cd>useMergedStore</cd> and not <cd>useStore</cd>, fundamentally, it's impossible to recombine multiple merge results. Understanding these limitations when using the merge function will help in effectively designing your application's state management structure and preventing unexpected issues.",
    "list": {
      "0": "<b>Appropriate Data Persistence</b>: The desktop sidebar is considered a user preference and is permanently stored, while the mobile sidebar is treated as temporary UI state.",
      "1": "<b>Flexible Architecture</b>: Each store is independently optimized while providing a unified interface.",
      "2": "<b>Maintainability</b>: Changes or additions to individual store middleware don't affect component code that uses the merged store.",
      "3": "<b><cd>context</cd></b> (or default behavior if the option is omitted): The corresponding useStore part follows the nearest Provider context. If there is no enclosing Provider, it uses the top-level (global) store created by create.",
      "4": "<b><cd>root</cd></b>: The corresponding useStore part always fetches its value directly from the top-level (global) store created by create, regardless of the presence of a Provider context.",

      "5": "<b>Cannot Merge Stores Using reducer Middleware</b>: useStore hooks created using the reducer middleware cannot be merged with other stores via the merge function. Attempting to do so will result in a type error in a TypeScript environment, preventing it beforehand. This is because the reducer middleware fundamentally changes how the setValue function behaves, and its state update logic differs from a typical useStore. The merge function operates on the assumption that each useStore adheres to the standard [value, setValue] interface, thus leading to compatibility issues with stores using reducer.",
      "6": "<b>Maximum Merge Count Limit</b>: As briefly mentioned earlier, the merge function can only merge up to 8 useStore hooks at a time. Attempting to merge more than 8 stores will result in the following error:",
      "7": "<b>React Hook Rules</b>: Internally, the merge function uses useContext to get the context value of each useStore. React Hooks have a rule that they cannot be called inside loops or conditional statements, which imposes constraints on dynamically handling an unlimited number of contexts.",
      "8": "<b>Performance Considerations</b>: While it might be theoretically possible to implement merging for more stores, as the number of merged stores increases, the internal logic becomes more complex, and there's a potential for performance degradation during state changes, subscriptions, and updates. The limit of 8 can be seen as a balance between usability and performance."
    }
  },
  "middlewares": {
    "logger": {
      "0": "The logger middleware is automatically disabled in a <cd>NODE_ENV=production</cd> environment, preventing unnecessary code from being included in the production build or impacting performance.",
      "1": "The logger middleware allows you to track state changes in real time and debug your application more effectively. It logs the previous and next state to the console every time the state updates, helping developers easily understand the flow of state changes.",
      "2": "It supports various options such as timestamp display, state diff logging, and log group collapsing/expanding, allowing you to tailor the logging output to your needs. This is especially useful in applications with complex state management, helping identify bugs and understand state transitions more clearly."
    },
    "devtools": {
      "0": "The devtools middleware is automatically disabled in a <cd>NODE_ENV=production</cd> environment, preventing unnecessary code from being included in the production build or impacting performance.",
      "1": "The devtools middleware in caro-kann makes state management more intuitive and efficient. This middleware enables real-time tracking of state changes through the Redux DevTools extension. Developers gain clear visibility into how the state evolves, making debugging and optimization easier.",
      "2": "For example, managing a count state with the devtools middleware allows real-time observation of state changes. Each button click, whether incrementing or decrementing the state, is recorded in Redux DevTools. This simplifies complex state management and debugging, significantly enhancing developer productivity."
    },
    "debounce": {
      "0": "The debounce middleware is a powerful tool for efficiently managing rapid, successive state updates. It works by collecting multiple quick state changes over a short period (default: 300ms) and then applying only the final update after the specified time has passed since the last event.<br></br><br></br>This approach is especially beneficial in scenarios with frequent events—such as search input, form changes, or window resizing—as it helps prevent unnecessary renders and computations, thereby significantly improving application performance.",
      "1": "The real strength of the debounce middleware lies in its ability to preserve all update intents while optimizing performance—not just applying the last one blindly. This is particularly useful when users trigger multiple interactions (e.g., clicks or keystrokes) in a short span, ensuring that each action is respected in order while still avoiding redundant updates."
    },
    "persist": {
      "0": "caro-kann allows global state to be stored in local storage, session storage, and cookies. This feature is especially important for improving user experience and is suitable for values that need to persist even after a page refresh or session termination, such as the theme settings of a webpage.",
      "1": "When storing global state in caro-kann, the state is stored alongside a version. This allows the application to easily transform or disregard data from previous versions if the state structure changes.",
      "2": "For example, suppose the theme needs to support not only background color but also font size. caro-kann handles this by using the migrate array. When a migrate object is present, caro-kann automatically checks for version differences whenever a client connects to the service. If the client's state is not up to date, it calls the appropriate function(s) in the array to transform the old state into the updated version, ensuring the client always works with the latest schema.",
      "3": "We successfully used migrate to update version 0 to version 1. However, a few weeks later, a senior developer comes by and requests that the font state property be renamed to font-size. Since migrate only runs when a client connects to the service, any user who hasn't connected yet still retains version 0 of the state. Therefore, we now need to handle both version 0 and version 1 during the migration process.<br></br><br></br>But don't worry! To address this, the migrate array is structured like a pipeline.",
      "4": "With the help of TypeScript, the migrate pipe enforces two key conditions. First, the return type of a function at a given index must match the parameter type of the function at the next index. This ensures that each step in the migration process is type-safe and properly connected, allowing TypeScript to catch potential type mismatches at compile time and prevent runtime errors. Additionally, the return type of the final function in the pipe must exactly match the current global state type used by the application, ensuring that the final migrated state is fully compatible with the rest of the application logic."
    },
    "validate": {
      "0": "The validate middleware is a useful tool for enhancing type safety in state management. This middleware validates data against a predefined schema before the state is changed. This helps maintain state consistency and stability by preventing invalid data from being reflected in the application state. If an invalid state change attempt occurs, the change is blocked, and detailed error information is immediately printed to the console, facilitating debugging.",
      "1": "The validate middleware in caro-kann internally utilizes <a><cd>@ilokesto/common-resolver</cd></a>, allowing for easy integration with various widely used validation libraries such as zod (v3, v4), yup, and superstruct. This offers the advantage that developers can effectively manage the integrity of state data using familiar tools or those already implemented in their projects."
    },
    "reducer": {
      "0": "The reducer middleware in caro-kann handles centralized state transformations, making state changes predictable and consistent. This pattern, commonly used in Redux, is designed to update state while maintaining immutability. The reducer middleware primarily changes state through actions, centralizing state update logic.",
      "1": "When the reducer middleware is used, useStore returns a tuple <cd>[value, dispatch]</cd> instead of <cd>[value, setValue]</cd>. The dispatch function takes an action object as its argument, triggering the logic defined in the reduceFn to update the state. The reduceFn is responsible for updating the state based on the type of each action, using the type and payload properties of the action object to define the update logic."
    },
    "composition": {
      "title": "Middleware Composition",
      "0": "All of caro-kann's middleware, except for the reducer middleware, can be <b>freely composed without any conditions</b>. This means that when multiple middlewares are used together, each middleware operates independently without interfering with each other.<br></br><br></br>For example, when using the logger, validate, and debounce middlewares together, the state change is first validated through validate, then optimized by debounce at the appropriate time, and finally logged to the console via logger, ensuring a smooth flow. This composition of middlewares helps developers combine various functionalities flexibly, ensuring both the accuracy of state management and the performance of the application.<br></br><br></br>Unlike other middlewares, the reducer middleware must be placed immediately below the create function. This is because the reducer returns dispatch instead of setState.",
      "subtitle1": "Understanding Middleware Composition Results",
      "1": "Most middleware can be composed freely without any specific restrictions. Developers can arrange the middleware in any order, and in many cases, there are no special conditions to consider during the composition. However, the way and order in which middleware is composed can result in significantly different behaviors, or in some cases, no impact at all.<br></br><br></br>For example, in the case below, the execution order of the persist and validate middleware does not affect the result, as both middleware do not influence each other's behavior.",
      "2": "On the other hand, in the following example, the behavior depends on the order in which the debounce and logger middleware are composed. If logger is executed first, all state change logs will be recorded before debouncing. Conversely, if debounce is executed first, any state changes within a short time frame will be ignored, and only the final change will be logged. This shows that some middleware can influence each other's behavior, so it's important to carefully consider the meaning of the composition order when deciding on the sequence.",
      "3": "To understand the results of middleware composition, it's essential to see how caro-kann applies and processes middleware. In caro-kann, each middleware wraps the state and is executed sequentially, so the return value of one middleware is passed as the input to the next. As middleware are composed functionally, the order in which each middleware performs actions such as validation, storage, etc., can significantly affect the final behavior. Therefore, it is advisable to thoroughly understand the purpose and interactions of the middleware before determining the appropriate composition order."
    }
  }
}

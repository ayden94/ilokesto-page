{
  "introduce": {
    "title": "Introduce the caro-kann",
    "description": "caro-kann is a global state management tool internally built with the useSyncExternalStore hook. It supports TypeScript and is compatible with both Next.js and React.js. With a syntax similar to useState, caro-kann is intuitive for developers familiar with React.js.",
    "whatsNew": "Whatâ€™s new in caro-kann@4.0.0",
    "newArray": [
      "The Zustand middleware has now been completely removed. Also, the usage of the validate middleware has changed.",
      "<cd>useStore.derived</cd> has been renamed to <cd>useStore.readOnly</cd>. Additionally, a <cd>writeOnly</cd> method has been added to <cd>useStore</cd>. This allows for clearer and more efficient state management, even in components that need to change state but do not need to subscribe to the state directly. These changes make the code's intent clearer and contribute to reducing unnecessary re-renders.",
      "The provider, which was removed in the previous version, has returned. This allows for the configuration of independent state trees within specific contexts, further enhancing the application's flexibility and reusability.",
      "All rules to follow when writing selector functions have been removed. Consequently, developers can define selector functions freely without unnecessary constraints, which contributes to increasing the code's flexibility and expressiveness. Internally, selector processing has been improved, enabling stable state management without performance degradation despite this freedom.",
      "<cd>setValue</cd> now always operates consistently, regardless of the presence or absence of a selector function. This change enhances the API's intuitiveness and significantly helps reduce the possibility of bugs caused by exceptional behavior. As a result, developers can update state in a more predictable and stable manner.",
      "An <cd>adaptor</cd> utility function has been added for use with <cd>setValue</cd> to easily change complex object states.",
      "A <cd>merge</cd> utility function has been added to combine multiple <cd>useStore</cd> instances. This allows developers to flexibly configure state using either a top-down approach with <cd>selector function + adaptor</cd> or a bottom-up approach with <cd>merge</cd>. Each approach can be selectively applied depending on the component structure or data flow, effectively addressing various architectural requirements. Overall, this update is an improvement that considers both consistency and scalability, significantly enhancing productivity and maintainability in actual development environments."
    ],
    "installation": "Installation",
    "installationBody": "caro-kann can be installed in various ways as below.",
    "createStore": "Create a store"
  },
  "tutorials": {
    "title": "Tutorial: Building a Shopping Cart",
    "description": "This tutorial guides you through the process of implementing a simple yet practical shopping cart feature using the caro-kann library in a React environment. You will learn how to efficiently manage state and easily integrate various additional features through caro-kann's intuitive state management approach and powerful middleware system.<br></br><br></br>This tutorial is aimed at developers with a basic understanding of React and aims to help you grasp the core concepts and practical usage of caro-kann so that you can apply it to real projects.",
    "createStore": {
      "title": "Create a store",
      "0": "Before starting application state management, it's a good idea to first define the structure of the data we'll be working with. Here, we create a TypeScript type to clearly specify the attributes of a 'Product' that will be placed in the shopping cart. Each product should have a required id, name, and price, and may optionally include imageUrl and description. Defining the type upfront helps reduce data-related errors during development and improves code readability and maintainability.",
      "1": "Next, we import the <cd>create</cd> function from the caro-kann library to create a global state store. The <cd>create</cd> function takes an initial state value as an argument and returns a custom hook that can manage that state. In this example, we set an empty array <cd>[]</cd> as the initial state, indicating that the shopping cart is initially empty. The <cd>useCart</cd> hook, returned by the <cd>create'<'Array'<'Product'>>'([])</cd> call, will now be the core interface used by all components in our application to access and modify the shopping cart state."
    },
    "useCart": {
      "title": "Changing Global State with useCart",
      "0": "Now let's look at how to change the shopping cart state in actual components using the <cd>useCart</cd> hook we created.<br></br><br></br>First, the <cd>ProductBinder</cd> component receives a list of products (<cd>productList</cd>) from the server as props and is responsible for rendering a <cd>ProductCard</cd> component for each product. It acts as a list renderer, serving as a container to display multiple product information on the screen.",
      "1": "Calling the <cd>useCart()</cd> hook inside this component returns a tuple containing the current cart state (<cd>cart</cd>) and a function to change the state (<cd>setCart</cd>), similar to React's <cd>useState</cd> hook.",
      "2": "In the <cd>onClick</cd> handler of the 'Add to Cart' button, the <cd>setCart</cd> function is used. It employs a functional update approach (<cd>setCart(prev => [...prev, product])</cd>), taking the previous state (<cd>prev</cd>) and returning a new array with the new product (<cd>product</cd>) added to the end. This is a good pattern for maintaining state immutability and helps React detect changes and update the UI efficiently.<br></br><br></br>However, looking at the current implementation of the <cd>ProductBinder</cd> component, it doesn't display the contents of the cart. That is, it doesn't need to read the <cd>cart</cd> state value directly; it only performs the function of adding items to the cart via the <cd>setCart</cd> function. In such cases, optimization can be considered to prevent the component from unnecessarily re-rendering whenever the cart state changes.<br></br><br></br>caro-kann provides the <cd>writeOnly</cd> method built into the <cd>useCart</cd> hook for such situations. Using <cd>useCart.writeOnly()</cd> retrieves only the state-modifying function (corresponding to <cd>setCart</cd>) without fetching the state value itself.",
      "3": "This allows the <cd>ProductBinder</cd> component to not subscribe to changes in the current state of the cart, enabling it to solely perform the role of adding products while avoiding unnecessary re-renders. This is a useful optimization technique that can contribute to performance improvements, especially when state changes frequently or many components share the same state."
    },
    "readOnly": {
      "title": "Managing Derived State with readOnly method",
      "0": "The application's Header component plays an important role in visually showing the user the total number of products currently in the shopping cart. To implement this feature, we utilize the <cd>readOnly</cd> method of the <cd>useCart</cd> hook.<br></br><br></br>The <cd>readOnly</cd> method is a powerful feature that allows access to the current value of the state store to extract or calculate desired data. This method takes a callback function as an argument, and this callback function receives the current state (<cd>store</cd>) as a parameter and returns a derived value.<br></br><br></br>In the example below, <cd>useCart.readOnly(store => store.length)</cd> is used to calculate the total number of products in the cart (<cd>cartLength</cd>) through the <cd>length</cd> property of the cart array (<cd>store</cd>).",
      "1": "The main advantages of using <cd>readOnly</cd> are as follows:",
      "2": "Consequently, <cd>useCart.readOnly</cd> is very useful for creating components that depend only on specific parts of the state or derived values, and it helps improve the reactivity and performance of the application.",
      "list": {
        "0": "<b>Selective Subscription</b>: The component re-renders only in response to changes in the specific value returned by the callback function, not the entire state object. For example, the <cd>Header</cd> component will only re-render when products are added or removed from the cart, changing <cd>store.length</cd>. If only an attribute of a specific item in the cart changes but the total count remains the same, this component will not re-render, reducing unnecessary operations.",
        "1": "<b>Derived State Calculation</b>: It's not just about fetching a part of the state; you can create calculated values (derived state) based on the state. For example, logic to calculate the total cart amount or to filter and show the count of items meeting specific criteria can be handled within the <cd>readOnly</cd> callback.",
        "2": "<b>Performance Optimization</b>: By subscribing precisely to only the necessary data, it prevents unnecessary re-renders that occur when other parts of the state change. This significantly contributes to performance optimization, especially in applications with complex state structures or frequent state updates."
      }
    },
    "cartPage": {
      "title": "Creating the Cart Page",
      "0": "The cart page displays a list of products selected by the user and provides functionality to remove individual products or clear the entire cart. It also calculates and displays the total amount for all products in the cart. This page is primarily composed of a <cd>Cart</cd> component, and each cart item can be rendered via <cd>ProductCard</cd> (or a separate <cd>CartItemCard</cd>).<br></br><br></br>In the <cd>Cart</cd> component, a selector function is passed to the <cd>useCart</cd> hook to efficiently retrieve only the necessary data. This selector function takes the current cart state (<cd>store</cd>) as an argument and returns an object containing the list of cart items (<cd>items</cd>) and the total price of all items (<cd>priceTotal</cd>). This way, the <cd>Cart</cd> component only re-renders when the cart items or the total amount changes.",
      "list": {
        "0": "<cd>items</cd>: An array of product objects currently in the cart.",
        "1": "<cd>priceTotal</cd>: The sum of <cd>product.price</cd> for each item in the <cd>items</cd> array."
      }
    },
    "middleware": {
      "title": "Extending Cart Functionality with Middleware Composition: Backup and Action Verification",
      "0": "One of caro-kann's powerful features is the ability to easily compose middleware to extend store functionality. Here, we'll apply <cd>persist</cd> and <cd>logger</cd> middleware to keep the cart state in the browser and easily track state changes.",
      "subtitle1": "1. Persisting cart state with persist middleware",
      "1": "By default, an web application's state is reset when the page is refreshed or the browser is closed. To prevent users from losing the products they've added to their cart, the state needs to be stored somewhere. The <cd>persist</cd> middleware makes managing this state persistence very simple.<br></br><br></br>The <cd>persist</cd> middleware automatically saves data to a specified storage (e.g., <cd>localStorage</cd>) whenever the state changes, and restores the state by loading this data when the application reloads. Here's how to apply the <cd>persist</cd> middleware to the <cd>useCart</cd> store:",
      "subtitle2": "2. Tracking state changes with logger middleware",
      "2": "During development, understanding how the state changes and what actions caused those changes is crucial for debugging. The <cd>logger</cd> middleware helps track this process easily by printing state change-related information to the console.<br></br><br></br>The <cd>logger</cd> middleware can be composed with the <cd>persist</cd> middleware. Middleware is applied by wrapping functions, so you can think of it as executing from the inside out. That is, when a state change occurs, <cd>logger</cd> acts first, then <cd>persist</cd> acts.",
      "3": "Now, whenever a product is added to or removed from the cart, relevant logs will be printed to the browser console, allowing clear verification of the state change process. You can also adjust logger options to selectively view only the necessary information."
    },
    "merge": {
      "title": "Merging stores with merge",
      "0": "As an application grows, it can be more efficient to manage related states in separate stores. For example, cart state can be managed in a <cd>useCart</cd> store, and user profile information in a <cd>useProfile</cd> store.<br></br><br></br>caro-kann provides a <cd>merge</cd> utility to conveniently use and manage these separated stores as a single, unified hook. <cd>merge</cd> takes multiple store hooks as input and returns a new hook that can access the state and setter functions of each store.<br></br><br></br>First, define the individual stores. Here, we'll use cart (<cd>useCart</cd>) and user profile (<cd>useProfile</cd>) stores as examples. A <cd>User</cd> type also needs to be defined.",
      "1": "Now, use the <cd>merge</cd> utility to combine the <cd>useCart</cd> and <cd>useProfile</cd> stores. Pass an object to the <cd>merge</cd> function, where each key will be the name used in the merged store, and the value will be the respective store hook.",
      "2": "Using the <cd>useProfileAndCart</cd> hook created this way, you can access the state and setter functions of each store as if dealing with one large store.<br></br><br></br>For example, within a component, you can use it as follows:"
    },
    "finishing": {
      "title": "Wrapping up: Efficient State Management with caro-kann",
      "0": "So far, we've explored how to implement basic shopping cart functionality using the caro-kann library. Through this tutorial, you've learned how to create a store with the <cd>create</cd> function, read and update state via the <cd>useCart</cd> hook, optimize with <cd>writeOnly</cd> and <cd>readOnly</cd> methods, and manage derived state using selectors. We also looked at how to easily extend store functionality by composing <cd>persist</cd> and <cd>logger</cd> middleware, and how to manage multiple stores integratively with the <cd>merge</cd> utility.<br></br><br></br>The topics covered here are just a part of the diverse features caro-kann offers. In actual application development, you'll encounter more complex state logic, asynchronous operations, advanced middleware usage, and various other scenarios. caro-kann provides powerful and flexible features to meet these advanced requirements, helping developers handle state management more efficiently and intuitively.<br></br><br></br>For deeper learning and to explore the full potential of caro-kann, we highly recommend referring to the official documentation. The official documentation provides detailed guidance on various APIs not covered in this tutorial, advanced usage patterns, and best practices for real-world production environments. We hope you have a more enjoyable and productive state management experience with caro-kann."
    }
  },
  "create-store": {
    "title": "Creating a Store",
    "0": "In Caro-Kann, a store is defined as an external space where global state is saved. To create such a store, you must use the <cd>create</cd> function provided by Caro-Kann. This function takes the initial value of the state as a parameter, stores it in an internal store, and returns a <cd>useStore</cd> hook.<br></br><br></br>The <cd>create</cd> function must be called outside of a component. If called inside a component, a new store will be created every time the component re-renders, causing the previous state to be lost. This behavior contradicts the purpose of global state management, so special care must be taken.",
    "1": "The <cd>useStore</cd> hook is the only way to access the store created through the <cd>create</cd> function, and it returns a tuple of <cd>[value, setValue]</cd>, just like React's <cd>useState</cd> hook."
  },
  "basic-usage": {
    "title": "Basic Usage of useStore",
    "0": "As we've seen before, <cd>useStore</cd> returns a tuple of <cd>[value, setValue]</cd>, just like React's <cd>useState</cd> hook. Therefore, any developer familiar with React can easily use <cd>useStore</cd>.",
    "subtitle1": "Selector Function",
    "1": "The code we looked at above has one problem. Although the component only needs the email, name, and phoneNumber states, <cd>useStore</cd> is subscribing to the entire store. Therefore, if the age value changes elsewhere, the <cd>ProfileCard</cd> component, which doesn't need the age value, will also re-render.<br></br><br></br>To solve this problem, the <cd>useStore</cd> hook can take a selector function as an argument. By using a selector function, components can subscribe only to the state they actually need, preventing unnecessary re-renders. This is particularly helpful for rendering optimization in applications where the state object is large and complex, or where performance is critical.",
    "subtitle2": "Derived State",
    "2": "Selector functions not only prevent unnecessary re-renders by subscribing only to the required state but can also transform or calculate existing state to create new derived state.<br></br><br></br>For example, you can separate complex logic, such as calculating the total price from a list of cart items or determining adulthood from user data, outside the component. This approach helps keep UI components concise and allows state logic to be managed in a reusable form.",
    "subtitle3": "readOnly and writeOnly Methods",
    "3": "useStore returns a tuple of <cd>[value, setValue]</cd>. But does it always have to? The <cd>ProfileCard</cd> component we've looked at so far only fetches and uses state; it doesn't need the functionality to change state. In this case, the setValue function is unused and can be an unnecessary resource.<br></br><br></br>To address this situation, useStore provides <cd>readOnly</cd> and <cd>writeOnly</cd> methods. The readOnly method is for components that only read state, returning only the state value and not providing an update function. Conversely, the writeOnly method can be used when you only want to change state and not subscribe to it. This allows you to use an optimized interface tailored to the actual needs of the component."
  },
  "provider": {
    "title": "Provider",
    "0": "There's one more special method hidden in `useStore`. The `Provider` method is a special feature provided by Caro-Kann that allows you to configure independent state trees while using the same store. This feature enables the creation and management of different instances of the same store within an application.<br></br><br></br>Provider acts like a React component and receives the store as props. `useStore` is a means to access the store created via `create`, not the store itself. Therefore, Caro-Kann provides a `createStore` function that returns the store directly, instead of `useStore`. This allows you to provide independent state to specific component trees.",
    "subtitle1": "Use Cases",
    "1": "Provider is particularly useful in the following situations:",
    "2": "Through Provider, you can significantly enhance the flexibility of state management and achieve both state isolation and reusability in complex applications.",
    "subtitle2": "Provider and Middleware",
    "3": "As we will explore in more detail later, Caro-Kann's middleware adds additional functionality to create and createStore. And Provider works without issues regardless of which middleware is used or in what order, as long as the store types are the same. It even works correctly if different middlewares are applied to create and createStore, as shown in the example below.",
    "4": "However, there is one exception. If the reducer middleware is used with the create function, the same reducer middleware must also be used with the createStore function, and vice versa. This is because the reducer middleware modifies the behavior of setValue, the core function for changing the store's state. Therefore, if the usage of reducer middleware is inconsistent between create and createStore, unexpected issues can arise in the state update logic.<br></br><br></br>Fortunately, when using TypeScript, Caro-Kann internally and automatically identifies the middleware applied to each store. If an inconsistency in reducer middleware usage is detected, it informs the developer with the following warning message:",
    "5": "\"Warning: Reducer usage must be consistent. Both should use reducers, or neither should.\"",
    "6": "This helps prevent potential errors that might occur during the development process.",
    "list": {
      "0": "Testing environments: Provides independent state for each test, enabling isolated testing.",
      "1": "Multiple instance components: When the same component is used multiple times but needs to have independent states.",
      "2": "Theme management: When different parts of the application need to use different theme settings.",
      "3": "User-specific settings: When independent state management is needed for each user in a multi-user interface."
    }
  }
}

{
  "introduce": {
    "title": "Introduce the common-resolver",
    "description": "common-resolver is a lightweight, universal library designed to solve recurring validation and error-handling problems in a simple and consistent way across different environments. It provides adapter interfaces for validation libraries such as zod, yup, and superstruct so you can swap and reuse validation logic with minimal changes. Its modular design makes it quick to integrate and easy to extend, while keeping configuration minimal.",
    "installation": "Installation",
    "installationBody": "You can install common-resolver using any of the methods shown below.",
    "subtitle0": "Features",
    "0": "common-resolver provides the following features. Along with resolvers for each schema validation library, it exposes type-safe helper functions that validate schemas. The getResolver function automatically detects the type of the provided schema and selects the appropriate resolver, so switching validation libraries requires minimal code changes.<br></br><br></br>Additionally, type definitions such as ValidateSchema and Resolver offer complete TypeScript safety, enabling IDE autocompletion and compile-time error checks. These features let developers focus on business logic instead of the intricacies of schema validation.",
    "1": "Below is a simple example using a Zod schema. The schema defines a string type with a minimum length of 1. Passing an empty string (\"\") to the validate method will fail the length check and produce an error object that includes a message (\"zSchema is required\") under the special \"root\" property. This example is for a single value, so errors are recorded on the \"root\" property instead of on a specific field. For complex object structures, errors are mapped to each field path accordingly.",
    "subtitle1": "Using common-resolver in the global state manager Caro-Kann",
    "2": "The code below demonstrates a middleware in the Caro-Kann global state manager that performs validation. The validate function accepts the initial state and a schema validator, and automatically validates whenever state changes. By using getResolver, the middleware can handle different schema types through the same interface. If the state is invalid, the middleware logs the error and blocks the state update, ensuring the application state always conforms to the schema.",
    "3": "Regardless of which validation library you use, passing a schema as the second argument to validate allows Caro-Kann to detect and pick the appropriate resolver via common-resolver. getResolver inspects the provided schema (Zod, Yup, Superstruct, etc.) and returns the matching resolver, so Caro-Kann users can replace schema objects without changing other code. This flexibility is especially useful when project requirements change or when experimenting with different validation libraries.",
    "subtitle2": "Using common-resolver in the form manager Sicilian",
    "4": "The Validate class inside Sicilian receives a state store, an error setter, and a Resolver object from common-resolver. Its doValidate method runs validation in response to user input events and sets field-specific error messages when validation fails. This structure provides immediate per-field feedback while maintaining overall form consistency.",
    "5": "Sicilian re-exposes common-resolver functionality through its own API, simplifying the developer experience and reducing direct dependencies on the common-resolver package.",
    "6": "The example below shows a complex signup form validated by a Zod schema. The schema includes rules for email, nickname, password, password confirmation, and terms agreement. It uses zod's refine method for cross-field checks such as ensuring password and passwordCheck match. The zodResolver passes this schema to the Sicilian form controller so all rules are enforced declaratively and user input is validated automatically."
  },
  "resolver": {
    "0": "A resolver provided by common-resolver accepts a schema from a validation library and returns a Resolver object.",
    "1": "The Resolver object exposes a validate method that returns one of two states depending on the validation result. If validation succeeds, valid is true and error is null; if validation fails, valid is false and the error object contains the fields and related information.<br></br><br></br>The error object mirrors the original data structure and is represented as nested entries so you can easily locate errors for specific fields. This consistent interface allows you to handle errors the same way regardless of which validation library you use, making it highly effective for form validation and data integrity checks.",
    "2": "The error object conforms to the CRES type. This type mirrors the original data shape but makes all properties optional and represents each value as a string message. The structure is applied recursively so nested objects retain the same pattern, which makes it straightforward to identify which field in a complex object caused the error."
  },
  "CRES": {
    "0": "common-resolver first transforms each raw error object into a CEF (Common ErrorObject Format). This normalizes different error shapes into a consistent structure, and then converts that structure into a user-friendly CRES (Common-Resolver ErrorObject Structure). These converters are defined inside each resolver, and the CEF has the form <cd>'{' [path: string]: string '}'</cd>.",
    "1": "CRES is the canonical error response format provided by common-resolver. It standardizes errors from various sources, allowing developers to manage disparate error shapes without writing custom parsing logic. Given an input value and the schema that validates it, CRES shows where errors occurred in a predictable layout.",
    "2": "CRES is shaped as shown below. Each entry may include a root property that represents an error for the object or array itself. If root is omitted, it can be difficult to express a top-level object error for nested entries like agreeToTerms.marketingTerms. The root field allows conveying both specific sub-property errors and general object-level errors, resulting in simpler and more flexible error handling.",
    "3": "common-resolver wraps CRES with a Proxy object. The Proxy does several helpful things: when accessing a path it can automatically return a root value for that path, and if a nested object exists it will return another Proxy so accesses are recursive. This lets developers navigate nested error structures without checking each level manually. The Proxy also prevents modifications or deletions of error properties, preserving the immutability of error messages. In cases where a property is present, the Proxy may synthesize a virtual entry to make lookups consistent and convenient.",
    "4": "Regarding the CRES type definition: only the top level may optionally contain root, while nested entries are treated as if they do not have root. At runtime TypeScript may consider the root field to be an object instead of a string, which is inconvenient when trying to read it directly. Although not ideal, the pragmatic approach is to use an explicit cast (as string) when accessing root values.",
    "5": "Consider a modification to RecursivePartial below. With this shape, deep property access using dot notation requires checking whether each step is a string or an object, otherwise TypeScript will complain. Rather than encoding precise runtime shapes, the practical choice is to assert the root value as string at the call site to avoid repeated type checks."
  }
}

{
  "introduce": {
    "title": "Introducing utilinent",
    "description": "As React apps grow, JSX often becomes cluttered with nested ternary operators and bloated map callbacks, which rapidly degrades readability. utilinent was created to solve these recurring UI patterns by providing small, declarative components.<br><br/><br><br/>Inspired by the concise and expressive style of SolidJS, utilinent encapsulates common tasks — conditional rendering, list rendering, and lazy loading — into clear APIs. For example, replace complex ternaries with a <cd>Show</cd> component, or use <cd>For</cd> to render arrays along with a built-in fallback for empty data.<br><br/><br><br/>By moving noisy logic out of views and into reusable components, utilinent improves readability, maintainability, and lets developers focus more on business logic while boosting team productivity.",
    "installation": "Installation",
    "installationBody": "You can install utilinent using the methods below.",
    "quickStart": "Quick start",
    "0": "When handling async data in React, it's common to render different UI for loading, empty, or populated states. The examples below show typical patterns and how utilinent components simplify them.",
    "1": "utilinent's <cd>Show</cd> and <cd>For</cd> components make conditional and list rendering more declarative and concise. They help express loading and list states clearly so your UI intent is easier to read and maintain."
  },
  "show": {
    "0": "<cd>Show</cd> is a declarative component for conditional rendering. When <cd>when</cd> is truthy it renders children; otherwise it renders the <cd>fallback</cd> (or nothing). This keeps branching logic out of JSX and makes intent explicit.",
    "subtitle1": "Basic usage",
    "1": "Pass a condition to <cd>when</cd> and optionally provide <cd>fallback</cd>. If children is a function, it receives the evaluated value at render time.",
    "subtitle2": "Multiple conditions (array)",
    "2": "If you pass an array to <cd>when</cd>, children render only when every item is truthy. The function child receives the array values.",
    "subtitle3": "DOM-preserving variants",
    "3": "Use <cd>Show.div</cd> or <cd>Show.span</cd> to keep an outer element in the DOM while swapping inner content."
  },
  "switch": {
    "0": "<cd>Switch</cd> renders the first matching <cd>Match</cd> child in order. Each <cd>Match</cd> is evaluated with the same truthiness rules as <cd>Show</cd>, and <cd>fallback</cd> is rendered when nothing matches.",
    "subtitle1": "Basic usage",
    "1": "Place multiple <cd>Match</cd> components inside <cd>Switch</cd> and provide an optional fallback.",
    "subtitle2": "Function children",
    "2": "If you pass a function to <cd>Match</cd>, it receives the evaluated value for that branch.",
    "subtitle3": "DOM-preserving variants",
    "3": "Use <cd>Switch.div</cd> to keep a wrapper element while swapping the matched content."
  },
  "mount": {
    "0": "<cd>Mount</cd> renders children that may be a function returning a value or a promise. While the promise resolves, it shows <cd>fallback</cd> and reports errors via <cd>onError</cd>.",
    "subtitle1": "Basic usage",
    "1": "Return a React node or a promise from the children function to defer rendering until it resolves.",
    "subtitle2": "Error handling",
    "2": "Use <cd>onError</cd> to capture thrown errors or rejected promises, and show a safe <cd>fallback</cd> UI.",
    "subtitle3": "DOM-preserving variants",
    "3": "<cd>Mount.div</cd> and other tag variants keep a wrapper element while the resolved content swaps in."
  },
  "optional": {
    "0": "<cd>OptionalWrapper</cd> conditionally applies a wrapper without duplicating markup. It uses <cd>Show</cd> internally, so truthy <cd>when</cd> values render the wrapped children and falsy values render the fallback or the original children.",
    "subtitle1": "Basic usage",
    "1": "Provide <cd>when</cd> and a <cd>wrapper</cd> function that receives the children and returns the wrapped result.",
    "subtitle2": "Custom fallback wrapper",
    "2": "Use <cd>fallback</cd> to return an alternate wrapper when the condition is false."
  },
  "observer": {
    "0": "<cd>Observer</cd> renders children only when the element becomes visible in the viewport. Provide a <cd>fallback</cd> for the hidden state and optionally react to intersections.",
    "subtitle1": "Basic usage",
    "1": "Render a placeholder with <cd>fallback</cd> and mount heavy content only after the element intersects.",
    "subtitle2": "Trigger once and callbacks",
    "2": "Set <cd>triggerOnce</cd> to stop observing after the first intersection and use <cd>onIntersect</cd> for side effects.",
    "subtitle3": "useIntersectionObserver hook",
    "3": "The hook exposes <cd>ref</cd>, <cd>isIntersecting</cd>, and the latest <cd>entry</cd> for custom intersection-driven behavior."
  },
  "slacker": {
    "0": "<cd>Slacker</cd> loads data when it enters the viewport. It combines <cd>Observer</cd> with a <cd>loader</cd> function and supports loading, error, and retry states.",
    "subtitle1": "Basic usage",
    "1": "Provide a <cd>loader</cd> and render the loaded data in children once it becomes visible.",
    "subtitle2": "Error handling & retries",
    "2": "Use <cd>errorFallback</cd>, <cd>maxRetries</cd>, and <cd>retryDelay</cd> to handle failures gracefully."
  },
  "for": {
    "0": "<cd>For</cd> renders arrays with an optional empty-state fallback. It replaces <cd>map</cd> plus extra conditionals with a single declarative block.",
    "subtitle1": "Basic usage",
    "1": "Render items with a callback and provide <cd>fallback</cd> for empty, null, or undefined arrays.",
    "subtitle2": "DOM-preserving variants",
    "2": "Use <cd>For.ul</cd> or <cd>For.div</cd> to keep a container element while swapping the inner list.",
    "subtitle3": "Keys and stable rendering",
    "3": "Provide stable <cd>key</cd> values on the elements returned by the render function."
  },
  "repeat": {
    "0": "<cd>Repeat</cd> renders a block a fixed number of times. It is useful for skeletons, star ratings, and placeholders.",
    "subtitle1": "Basic usage",
    "1": "Provide a positive integer <cd>times</cd> and render a callback that receives the current index. If <cd>times</cd> is not a positive integer, <cd>fallback</cd> is rendered.",
    "subtitle2": "DOM-preserving variants",
    "2": "<cd>Repeat.div</cd> and similar variants keep a wrapper element while repeating children."
  },
  "slot": {
    "0": "<cd>Slot</cd> implements a flexible composition pattern for components that need to render as different elements. Sometimes a Button component must render as a native <cd>button</cd> or as an <cd>a</cd> depending on usage. <cd>Slot</cd> merges parent props into the chosen child element while preserving styles, event handlers, and refs.",
    "subtitle1": "Basic usage",
    "1": "Use the <cd>asChild</cd> pattern to let consumers control the rendered element while maintaining the component's styling and behavior.",
    "subtitle2": "Slottable",
    "2": "Wrap parts of complex structures with <cd>Slottable</cd> to pass props to specific child elements—useful for buttons with icons or compound components."
  },
  "createProxy": {
    "0": "<cd>createProxy</cd> builds component families like <cd>Show.div</cd> or <cd>For.ul</cd>, and it can be used externally to create your own proxy components. The steps below walk through a Custom Clickable example.",
    "subtitle1": "Define props and base behavior",
    "1": "Start by defining a base component that contains the shared behavior. The proxy reuses this base for every tag.",
    "1a": "Why <cd>BaseClickableType&lt;X = object&gt;</cd>? The proxy must accept your custom props plus whatever props belong to each tag or registered component. <cd>X</cd> is the placeholder for those tag props, and <cd>X &amp; ClickableProps</cd> merges them. The default <cd>object</cd> keeps the base usable without extra props. Without the generic, variants like <cd>Clickable.div</cd> would lose native props such as <cd>className</cd>, <cd>href</cd>, or <cd>role</cd> at the type level.",
    "subtitle2": "Add renderForTag + ProxyType",
    "2": "Provide a tag renderer and declare the proxy type so tag variants like <cd>Clickable.div</cd> are typed.",
    "2a": "Why <cd>BaseClickableFn extends BaseTypeHelperFn</cd> and <cd>this[\"props\"]</cd>? <cd>ProxyType</cd> treats <cd>BaseTypeHelperFn</cd> as a type-level function. It injects each tag's props into the <cd>props</cd> slot, then evaluates <cd>type</cd> to produce the final call signature. Using <cd>this[\"props\"]</cd> makes the signature depend on the tag, so <cd>Clickable.div</cd> gets <cd>ComponentPropsWithRef&lt;\"div\"&gt;</cd> merged with <cd>ClickableProps</cd>, while <cd>Clickable.Link</cd> picks up registered component props. If you hardcode <cd>ClickableProps</cd> here, the tag-specific props will not flow through.",
    "subtitle3": "Register custom components (optional)",
    "3": "Register components under a category and augment <cd>UtilinentRegister</cd> for type-safe <cd>Clickable.*</cd> usage.",
    "subtitle4": "Usage examples",
    "4": "Use the default component or tag/component variants once registered."
  }
}
